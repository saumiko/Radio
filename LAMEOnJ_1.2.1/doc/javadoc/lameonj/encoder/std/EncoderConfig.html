<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_18) on Tue Dec 14 18:46:16 CET 2010 -->
<TITLE>
EncoderConfig (LAMEOnJ v1.2, doc. version v1.0)
</TITLE>

<META NAME="date" CONTENT="2010-12-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="EncoderConfig (LAMEOnJ v1.2, doc. version v1.0)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/EncoderConfig.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../lameonj/encoder/std/Encoder.html" title="interface in lameonj.encoder.std"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../lameonj/encoder/std/GenericEncoder.html" title="interface in lameonj.encoder.std"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?lameonj/encoder/std/EncoderConfig.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="EncoderConfig.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
lameonj.encoder.std</FONT>
<BR>
Interface EncoderConfig</H2>
<HR>
<DL>
<DT><PRE>public interface <B>EncoderConfig</B></DL>
</PRE>

<P>
This interface basically wraps the low level <A HREF="../../../lame/std/Lame.html" title="class in lame.std"><CODE>Lame</CODE></A>
 API with some added checking.

 <p>If an encoding process was started the configuration is freezed (no change
 is allowed).</p>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../lameonj/encoder/std/Encoder.html#getEncoderConfig()"><CODE>Encoder.getEncoderConfig()</CODE></A></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateBlockTypeHist(int[][])">bitrateBlockTypeHist</A></B>(int[][]&nbsp;bitrate_btype_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 
 void CDECL lame_bitrate_block_type_hist ( 
        const lame_global_flags * const gfp, 
        int bitrate_btype_count[14][6] );
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])">bitrateHist</A></B>(int[]&nbsp;bitrate_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateKbps(int[])">bitrateKbps</A></B>(int[]&nbsp;bitrate_kbps)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 
 void CDECL lame_bitrate_kbps( 
            const lame_global_flags *const gfp, 
            int bitrate_kbps [14] );  
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateStereoModeHist(int[][])">bitrateStereoModeHist</A></B>(int[][]&nbsp;bitrate_stmode_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 
 void CDECL lame_bitrate_stereo_mode_hist ( 
        const lame_global_flags * const gfp, 
        int  bitrate_stmode_count [14] [4] );
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#blockTypeHist(int[])">blockTypeHist</A></B>(int[]&nbsp;btype_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 
 void CDECL lame_block_type_hist (
        const lame_global_flags * const gfp, 
        int btype_count[6] );
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getAllowDiffShort()">getAllowDiffShort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow blocktypes to differ between channels?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getAthaaLoudapprox()">getAthaaLoudapprox</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select the loudness approximation used by the ATH adaptive auto-leveling  

 int CDECL lame_get_athaa_loudapprox( const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getAthaaSensitivity()">getAthaaSensitivity</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adjust (in dB) the point below which adaptive ATH level adjustment occurs 

 float CDECL lame_get_athaa_sensitivity( const lame_global_flags* );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getAthaaType()">getAthaaType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select ATH adaptive adjustment type 

 int CDECL lame_get_athaa_type( const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getATHlower()">getATHlower</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lower ATH by this many db 

 floag CDECL lame_get_ATHlower(lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getATHtype()">getATHtype</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select ATH formula 

 int CDECL lame_get_ATHtype(lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getAudiophileGain()">getAudiophileGain</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AudiophileGain value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getBrate()">getBrate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set one of brate compression ratio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getCompressionRatio()">getCompressionRatio</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getCwlimit()">getCwlimit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predictability limit (ISO tonality formula)

       int CDECL lame_get_cwlimit(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getEncoderDelay()">getEncoderDelay</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encoder delay   

 int CDECL lame_get_encoder_delay(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getEncoderPadding()">getEncoderPadding</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding appended to the input to make sure decoder can fully decode
      all input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getExperimentalX()">getExperimentalX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_get_experimentalX(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getExperimentalY()">getExperimentalY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another experimental option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getExperimentalZ()">getExperimentalZ</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another experimental option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getExpNspsytune()">getExpNspsytune</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getExtension()">getExtension</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MP3 'private extension' bit  Meaningless.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getFrameNum()">getFrameNum</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of frames encoded so far 

      int CDECL lame_get_frameNum(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getFramesize()">getFramesize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size of MPEG frame 

      int CDECL lame_get_framesize(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getHighpassfreq()">getHighpassfreq</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq in Hz to apply highpass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getHighpasswidth()">getHighpasswidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of transition band, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getInSamplerate()">getInSamplerate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input sample rate in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getInterChRatio()">getInterChRatio</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use temporal masking effect (default = 1) 

 float CDECL lame_get_interChRatio(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getLameFlags()">getLameFlags</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The LAME flags associated to this configuration object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getLameShortVersion()">getLameShortVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char*  CDECL get_lame_short_version( void );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getLameUrl()">getLameUrl</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char*  CDECL get_lame_url( void );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getLameVersion()">getLameVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONAL:
 get the version number, in a string. of the form:  
 "3.63 (beta)" or just "3.63".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getLameVersionNumerical(lame.std.lame_version_t)">getLameVersionNumerical</A></B>(<A HREF="../../../lame/std/lame_version_t.html" title="class in lame.std">lame_version_t</A>&nbsp;version)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getLameVeryShortVersion()">getLameVeryShortVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char*  CDECL get_lame_very_short_version( void );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getLowpassfreq()">getLowpassfreq</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq in Hz to apply lowpass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getLowpasswidth()">getLowpasswidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of transition band, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getMfSamplesToEncode()">getMfSamplesToEncode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of PCM samples buffered, but not yet encoded to mp3 data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getMode()">getMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
      default: lame picks based on compression ration and input channels     

 MPEG_mode CDECL lame_get_mode(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getModeAutoms()">getModeAutoms</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode_automs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getMsfix()">getMsfix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float CDECL lame_get_msfix(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getNoclipGainChange()">getNoclipGainChange</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gain change required for preventing clipping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getNoclipScale()">getNoclipScale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user-specified scale factor required for preventing clipping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getNogapCurrentindex()">getNogapCurrentindex</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter for gapless encoding 

 int CDECL lame_get_nogap_currentindex(const lame_global_flags*);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getNogapTotal()">getNogapTotal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter for gapless encoding 

 int CDECL lame_get_nogap_total(const lame_global_flags*);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getNumChannels()">getNumChannels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of channels in input stream. default=2  

 int CDECL lame_get_num_channels(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getNumSamples()">getNumSamples</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getOutSamplerate()">getOutSamplerate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output sample rate in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getPaddingType()">getPaddingType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default)    

       Padding_type CDECL lame_get_padding_type(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getPeakSample()">getPeakSample</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the peak sample 

      float CDECL lame_get_PeakSample(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getPsyVersion()">getPsyVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char*  CDECL get_psy_version( void );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getQuality()">getQuality</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal algorithm selection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getQuantComp()">getQuantComp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select a different "best quantization" function. default=0  

       int CDECL lame_get_quant_comp(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getQuantCompShort()">getQuantCompShort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select a different "best quantization" function. default=0  

       int CDECL lame_get_quant_comp_short(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getRadioGain()">getRadioGain</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGain value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getScale()">getScale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getScaleLeft()">getScaleLeft</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the channel 0 (left) input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getScaleRight()">getScaleRight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the channel 1 (right) input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getSizeMP3buffer()">getSizeMP3buffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size (bytes) of mp3 data buffered, but not yet encoded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getTotalframes()">getTotalframes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lame's estimate of the total number of frames to be encoded
       only valid if calling program set num_samples

 int CDECL lame_get_totalframes(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getVBR()">getVBR</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Types of VBR.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getVBRMaxBitrateKbps()">getVBRMaxBitrateKbps</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_get_VBR_max_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getVBRMeanBitrateKbps()">getVBRMeanBitrateKbps</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ignored except for VBR=vbr_abr (ABR mode)     

        int CDECL lame_get_VBR_mean_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getVBRMinBitrateKbps()">getVBRMinBitrateKbps</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_get_VBR_min_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getVBRq()">getVBRq</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBR quality level.  0=highest  9=lowest
     
        int CDECL lame_get_VBR_q(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#getVersion()">getVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version  0=MPEG-2  1=MPEG-1  (2=MPEG-2.5)    

 int CDECL lame_get_version(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isAnalysis()">isAnalysis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=cause Lame to collect data for an MP3 frame analyzer. default=0
    
 int CDECL lame_get_analysis(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isATHonly()">isATHonly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only use ATH for masking 

 int CDECL lame_get_ATHonly(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isATHshort()">isATHshort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only use ATH for short blocks 

 int CDECL lame_get_ATHshort(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isBWriteVbrTag()">isBWriteVbrTag</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 = write a Xing VBR header frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isCopyright()">isCopyright</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark as copyright.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isDecodeOnly()">isDecodeOnly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=decode only.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isDecodeOnTheFly()">isDecodeOnTheFly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decode on the fly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isDisableReservoir()">isDisableReservoir</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable the bit reservoir.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isEmphasis()">isEmphasis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Input PCM is emphased PCM (for instance from one of the rarely
       emphased CDs), it is STRONGLY not recommended to use this, because
       psycho does not take it into account, and last but not least many decoders
       ignore these bits      

 int CDECL lame_get_emphasis(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isErrorProtection()">isErrorProtection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_protection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isFindPeakSample()">isFindPeakSample</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as lame_set_decode_on_the_fly() 
       default = 0 (disabled) 

 int CDECL lame_get_findPeakSample(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isFindReplayGain()">isFindReplayGain</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perform ReplayGain analysis?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isForceMs()">isForceMs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;force_ms.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isForceShortBlocks()">isForceShortBlocks</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;force short blocks 

 int CDECL lame_get_force_short_blocks(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isFreeFormat()">isFreeFormat</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use free_format?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isNoATH()">isNoATH</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable ATH 

 int CDECL lame_get_noATH(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isNoShortBlocks()">isNoShortBlocks</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable short blocks 

       int CDECL lame_get_no_short_blocks(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isOgg()">isOgg</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=encode a Vorbis .ogg file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isOriginal()">isOriginal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark as original.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isReplayGainDecode()">isReplayGainDecode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as 
       lame_set_decode_on_the_fly() && lame_set_findReplayGain()
       default = 0 (disabled) 

 int CDECL lame_get_ReplayGain_decode(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isReplayGainInput()">isReplayGainInput</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as lame_set_findReplayGain() 
       default = 0 (disabled) 

 int CDECL lame_get_ReplayGain_input(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isStrictISO()">isStrictISO</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enforce strict ISO compliance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isUseTemporal()">isUseTemporal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use temporal masking effect (default = 1) 

 int CDECL lame_get_useTemporal(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#isVBRHardMin()">isVBRHardMin</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=strictly enforce VBR_min_bitrate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#printConfig()">printConfig</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#printInternals()">printInternals</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void CDECL lame_print_internals( const lame_global_flags *gfp);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setAllowDiffShort(int)">setAllowDiffShort</A></B>(int&nbsp;allow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow blocktypes to differ between channels?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setAnalysis(boolean)">setAnalysis</A></B>(boolean&nbsp;analysis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=cause Lame to collect data for an MP3 frame analyzer. default=0 
 int CDECL lame_set_analysis(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setAsmOptimizations(int, int)">setAsmOptimizations</A></B>(int&nbsp;param1,
                    int&nbsp;param2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_asm_optimizations( lame_global_flags*  gfp, int, int );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setAthaaLoudapprox(int)">setAthaaLoudapprox</A></B>(int&nbsp;loud)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select the loudness approximation used by the ATH adaptive auto-leveling  

 int CDECL lame_set_athaa_loudapprox( lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setAthaaSensitivity(float)">setAthaaSensitivity</A></B>(float&nbsp;sen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adjust (in dB) the point below which adaptive ATH level adjustment occurs 

 int CDECL lame_set_athaa_sensitivity( lame_global_flags *, float);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setAthaaType(int)">setAthaaType</A></B>(int&nbsp;ATHadjust)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select ATH adaptive adjustment type 

 int CDECL lame_set_athaa_type( lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setATHlower(float)">setATHlower</A></B>(float&nbsp;ATHLower)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lower ATH by this many db 

 int CDECL lame_set_ATHlower(lame_global_flags *, float);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setATHonly(boolean)">setATHonly</A></B>(boolean&nbsp;athOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only use ATH for masking 

 int CDECL lame_set_ATHonly(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setATHshort(boolean)">setATHshort</A></B>(boolean&nbsp;athShort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only use ATH for short blocks 

 int CDECL lame_set_ATHshort(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setATHtype(int)">setATHtype</A></B>(int&nbsp;ATHType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select ATH formula 

 int CDECL lame_set_ATHtype(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setBrate(int)">setBrate</A></B>(int&nbsp;brate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set one of brate compression ratio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setBWriteVbrTag(boolean)">setBWriteVbrTag</A></B>(boolean&nbsp;vbrTag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 = write a Xing VBR header frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setCompressionRatio(float)">setCompressionRatio</A></B>(float&nbsp;ratio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setCopyright(boolean)">setCopyright</A></B>(boolean&nbsp;cprght)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark as copyright.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setCwlimit(int)">setCwlimit</A></B>(int&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predictability limit (ISO tonality formula) 

       int CDECL lame_set_cwlimit(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setDebugf(lame.std.LameMsgCallback)">setDebugf</A></B>(<A HREF="../../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONAL:
 Set printf like error/debug/message reporting functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setDecodeOnly(boolean)">setDecodeOnly</A></B>(boolean&nbsp;deconly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=decode only.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setDecodeOnTheFly(boolean)">setDecodeOnTheFly</A></B>(boolean&nbsp;onthefly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decode on the fly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setDisableReservoir(boolean)">setDisableReservoir</A></B>(boolean&nbsp;preset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable the bit reservoir.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setEmphasis(boolean)">setEmphasis</A></B>(boolean&nbsp;emph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Input PCM is emphased PCM (for instance from one of the rarely
       emphased CDs), it is STRONGLY not recommended to use this, because
       psycho does not take it into account, and last but not least many decoders
       ignore these bits      

 int CDECL lame_set_emphasis(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setErrorf(lame.std.LameMsgCallback)">setErrorf</A></B>(<A HREF="../../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONAL:
 Set printf like error/debug/message reporting functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setErrorProtection(boolean)">setErrorProtection</A></B>(boolean&nbsp;prot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_protection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setExperimentalX(int)">setExperimentalX</A></B>(int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_experimentalX(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setExperimentalY(int)">setExperimentalY</A></B>(int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another experimental option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setExperimentalZ(int)">setExperimentalZ</A></B>(int&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another experimental option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setExpNspsytune(int)">setExpNspsytune</A></B>(int&nbsp;tune)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setExpNspsytune2Int(int, int)">setExpNspsytune2Int</A></B>(int&nbsp;p1,
                    int&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int lame_set_exp_nspsytune2_int( lame_global_flags*, int, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setExpNspsytune2Pointer(int, int)">setExpNspsytune2Pointer</A></B>(int&nbsp;p1,
                        int&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * lame_set_exp_nspsytune2_pointer( lame_global_flags*, int, void *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setExpNspsytune2Real(int, float)">setExpNspsytune2Real</A></B>(int&nbsp;p1,
                     float&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float lame_set_exp_nspsytune2_real( lame_global_flags*, int, float);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setExtension(int)">setExtension</A></B>(int&nbsp;ext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MP3 'private extension' bit  Meaningless.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setFindPeakSample(boolean)">setFindPeakSample</A></B>(boolean&nbsp;findPeak)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as lame_set_decode_on_the_fly() 
       default = 0 (disabled) 

 int CDECL lame_set_findPeakSample(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setFindReplayGain(boolean)">setFindReplayGain</A></B>(boolean&nbsp;repGain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perform ReplayGain analysis?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setForceMs(boolean)">setForceMs</A></B>(boolean&nbsp;force)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;force_ms.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setForceShortBlocks(boolean)">setForceShortBlocks</A></B>(boolean&nbsp;force)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;force short blocks 

 int CDECL lame_set_force_short_blocks(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setFreeFormat(boolean)">setFreeFormat</A></B>(boolean&nbsp;free)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use free_format?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setHighpassfreq(int)">setHighpassfreq</A></B>(int&nbsp;freq)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq in Hz to apply highpass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setHighpasswidth(int)">setHighpasswidth</A></B>(int&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of transition band, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setInSamplerate(int)">setInSamplerate</A></B>(int&nbsp;rate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input sample rate in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setInterChRatio(float)">setInterChRatio</A></B>(float&nbsp;interChRatio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use temporal masking effect (default = 1) 

 int CDECL lame_set_interChRatio(lame_global_flags *, float);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setLowpassfreq(int)">setLowpassfreq</A></B>(int&nbsp;freq)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq in Hz to apply lowpass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setLowpasswidth(int)">setLowpasswidth</A></B>(int&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of transition band, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setMode(int)">setMode</A></B>(int&nbsp;mpeg_mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
      default: lame picks based on compression ration and input channels

 int CDECL lame_set_mode(lame_global_flags *, MPEG_mode);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setModeAutoms(int)">setModeAutoms</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode_automs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setMsfix(double)">setMsfix</A></B>(double&nbsp;msfix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void CDECL lame_set_msfix(lame_global_flags *, double);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setMsgf(lame.std.LameMsgCallback)">setMsgf</A></B>(<A HREF="../../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONAL:
 Set printf like error/debug/message reporting functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setNoATH(boolean)">setNoATH</A></B>(boolean&nbsp;noATH)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable ATH 

 int CDECL lame_set_noATH(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setNogapCurrentIndex(int)">setNogapCurrentIndex</A></B>(int&nbsp;currindex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter for gapless encoding 

 int CDECL lame_set_nogap_currentindex(lame_global_flags* , int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setNogapTotal(int)">setNogapTotal</A></B>(int&nbsp;total)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter for gapless encoding 

 int CDECL lame_set_nogap_total(lame_global_flags*, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setNoShortBlocks(boolean)">setNoShortBlocks</A></B>(boolean&nbsp;noShort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable short blocks 

       int CDECL lame_set_no_short_blocks(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setNumChannels(int)">setNumChannels</A></B>(int&nbsp;channels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of channels in input stream. default=2  

 int CDECL lame_set_num_channels(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setNumSamples(int)">setNumSamples</A></B>(int&nbsp;samples)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setOgg(boolean)">setOgg</A></B>(boolean&nbsp;ogg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=encode a Vorbis .ogg file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setOriginal(boolean)">setOriginal</A></B>(boolean&nbsp;original)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark as original.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setOutSamplerate(int)">setOutSamplerate</A></B>(int&nbsp;rate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output sample rate in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setPaddingType(int)">setPaddingType</A></B>(int&nbsp;padding_type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default)

       int CDECL lame_set_padding_type(lame_global_flags *, Padding_type);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setPreset(int)">setPreset</A></B>(int&nbsp;preset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_preset( lame_global_flags*  gfp, int );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setPresetExpopts(int)">setPresetExpopts</A></B>(int&nbsp;expopts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for preset 

 int CDECL lame_set_preset_expopts(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setQuality(int)">setQuality</A></B>(int&nbsp;quality)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal algorithm selection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setQuantComp(int)">setQuantComp</A></B>(int&nbsp;quant)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select a different "best quantization" function. default=0  

       int CDECL lame_set_quant_comp(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setQuantCompShort(int)">setQuantCompShort</A></B>(int&nbsp;quant)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select a different "best quantization" function. default=0  

       int CDECL lame_set_quant_comp_short(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setReplayGainDecode(boolean)">setReplayGainDecode</A></B>(boolean&nbsp;repGain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as 
       lame_set_decode_on_the_fly() && lame_set_findReplayGain()
       default = 0 (disabled) 

 int CDECL lame_set_ReplayGain_decode(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setReplayGainInput(boolean)">setReplayGainInput</A></B>(boolean&nbsp;repGain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as lame_set_findReplayGain() 
       default = 0 (disabled) 

 int CDECL lame_set_ReplayGain_input(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setScale(float)">setScale</A></B>(float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setScaleLeft(float)">setScaleLeft</A></B>(float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the channel 0 (left) input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setScaleRight(float)">setScaleRight</A></B>(float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the channel 1 (right) input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setStrictISO(boolean)">setStrictISO</A></B>(boolean&nbsp;iso)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enforce strict ISO compliance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setUseTemporal(boolean)">setUseTemporal</A></B>(boolean&nbsp;maskEffect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use temporal masking effect (default = 1) 

 int CDECL lame_set_useTemporal(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setVBR(int)">setVBR</A></B>(int&nbsp;vbr_mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Types of VBR.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setVBRHardMin(boolean)">setVBRHardMin</A></B>(boolean&nbsp;vbr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=strictly enforce VBR_min_bitrate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setVBRMaxBitrateKbps(int)">setVBRMaxBitrateKbps</A></B>(int&nbsp;bitrate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_VBR_max_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setVBRMeanBitrateKbps(int)">setVBRMeanBitrateKbps</A></B>(int&nbsp;bitrate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ignored except for VBR=vbr_abr (ABR mode) 

        int CDECL lame_set_VBR_mean_bitrate_kbps(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setVBRMinBitrateKbps(int)">setVBRMinBitrateKbps</A></B>(int&nbsp;bitrate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_VBR_min_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#setVBRQ(int)">setVBRQ</A></B>(int&nbsp;level)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBR quality level.  0=highest  9=lowest  

        int CDECL lame_set_VBR_q(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../lameonj/encoder/std/EncoderConfig.html#stereoModeHist(int[])">stereoModeHist</A></B>(int[]&nbsp;stereo_mode_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 
 void CDECL lame_stereo_mode_hist( 
            const lame_global_flags *const gfp, 
            int stereo_mode_count[4] );  
 </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getLameFlags()"><!-- --></A><H3>
getLameFlags</H3>
<PRE>
<A HREF="../../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A> <B>getLameFlags</B>()</PRE>
<DL>
<DD>The LAME flags associated to this configuration object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the flags object.</DL>
</DD>
</DL>
<HR>

<A NAME="setNumSamples(int)"><!-- --></A><H3>
setNumSamples</H3>
<PRE>
void <B>setNumSamples</B>(int&nbsp;samples)</PRE>
<DL>
<DD>number of samples.  default = 2^32-1   

 <pre>int CDECL lame_set_num_samples(lame_global_flags *, unsigned long);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNumSamples()"><!-- --></A><H3>
getNumSamples</H3>
<PRE>
int <B>getNumSamples</B>()</PRE>
<DL>
<DD>number of samples.  default = 2^32-1      

 <pre>unsigned long CDECL lame_get_num_samples(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setInSamplerate(int)"><!-- --></A><H3>
setInSamplerate</H3>
<PRE>
void <B>setInSamplerate</B>(int&nbsp;rate)</PRE>
<DL>
<DD>input sample rate in Hz.  default = 44100hz 

       <pre>int CDECL lame_set_in_samplerate(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInSamplerate()"><!-- --></A><H3>
getInSamplerate</H3>
<PRE>
int <B>getInSamplerate</B>()</PRE>
<DL>
<DD>input sample rate in Hz.  default = 44100hz      

        <pre>int CDECL lame_get_in_samplerate(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNumChannels(int)"><!-- --></A><H3>
setNumChannels</H3>
<PRE>
void <B>setNumChannels</B>(int&nbsp;channels)</PRE>
<DL>
<DD>number of channels in input stream. default=2  

 <pre>int CDECL lame_set_num_channels(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNumChannels()"><!-- --></A><H3>
getNumChannels</H3>
<PRE>
int <B>getNumChannels</B>()</PRE>
<DL>
<DD>number of channels in input stream. default=2  

 <pre>int CDECL lame_get_num_channels(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setScale(float)"><!-- --></A><H3>
setScale</H3>
<PRE>
void <B>setScale</B>(float&nbsp;scale)</PRE>
<DL>
<DD>scale the input by this amount before encoding.  default=0 (disabled)
 (not used by decoding routines)

 <pre>int CDECL lame_set_scale(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getScale()"><!-- --></A><H3>
getScale</H3>
<PRE>
float <B>getScale</B>()</PRE>
<DL>
<DD>scale the input by this amount before encoding.  default=0 (disabled)
 (not used by decoding routines)     

 <pre>float CDECL lame_get_scale(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setScaleLeft(float)"><!-- --></A><H3>
setScaleLeft</H3>
<PRE>
void <B>setScaleLeft</B>(float&nbsp;scale)</PRE>
<DL>
<DD>scale the channel 0 (left) input by this amount before encoding.
        default=0 (disabled)
      (not used by decoding routines)

 <pre>int CDECL lame_set_scale_left(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getScaleLeft()"><!-- --></A><H3>
getScaleLeft</H3>
<PRE>
float <B>getScaleLeft</B>()</PRE>
<DL>
<DD>scale the channel 0 (left) input by this amount before encoding.
        default=0 (disabled)
      (not used by decoding routines)
     
 <pre>float CDECL lame_get_scale_left(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setScaleRight(float)"><!-- --></A><H3>
setScaleRight</H3>
<PRE>
void <B>setScaleRight</B>(float&nbsp;scale)</PRE>
<DL>
<DD>scale the channel 1 (right) input by this amount before encoding.
        default=0 (disabled)
      (not used by decoding routines)

 <pre>int CDECL lame_set_scale_right(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getScaleRight()"><!-- --></A><H3>
getScaleRight</H3>
<PRE>
float <B>getScaleRight</B>()</PRE>
<DL>
<DD>scale the channel 1 (right) input by this amount before encoding.
        default=0 (disabled)
      (not used by decoding routines)     

 <pre>float CDECL lame_get_scale_right(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOutSamplerate(int)"><!-- --></A><H3>
setOutSamplerate</H3>
<PRE>
void <B>setOutSamplerate</B>(int&nbsp;rate)</PRE>
<DL>
<DD>output sample rate in Hz.  default = 0, which means Lame picks best value
      based on the amount of compression.  MPEG only allows:
      MPEG1    32, 44.1,   48khz
      MPEG2    16, 22.05,  24
      MPEG2.5   8, 11.025, 12
      (not used by decoding routines)
 
 <pre>int CDECL lame_set_out_samplerate(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOutSamplerate()"><!-- --></A><H3>
getOutSamplerate</H3>
<PRE>
int <B>getOutSamplerate</B>()</PRE>
<DL>
<DD>output sample rate in Hz.  default = 0, which means Lame picks best value
      based on the amount of compression.  MPEG only allows:
      MPEG1    32, 44.1,   48khz
      MPEG2    16, 22.05,  24
      MPEG2.5   8, 11.025, 12
      (not used by decoding routines)     
 
 <pre>int CDECL lame_get_out_samplerate(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAnalysis(boolean)"><!-- --></A><H3>
setAnalysis</H3>
<PRE>
void <B>setAnalysis</B>(boolean&nbsp;analysis)</PRE>
<DL>
<DD>1=cause Lame to collect data for an MP3 frame analyzer. default=0 
 <pre>int CDECL lame_set_analysis(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isAnalysis()"><!-- --></A><H3>
isAnalysis</H3>
<PRE>
boolean <B>isAnalysis</B>()</PRE>
<DL>
<DD>1=cause Lame to collect data for an MP3 frame analyzer. default=0
    
 <pre>int CDECL lame_get_analysis(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBWriteVbrTag(boolean)"><!-- --></A><H3>
setBWriteVbrTag</H3>
<PRE>
void <B>setBWriteVbrTag</B>(boolean&nbsp;vbrTag)</PRE>
<DL>
<DD>1 = write a Xing VBR header frame.
      default = 1
      this variable must have been added by a Hungarian notation Windows programmer :-)

 <pre>int CDECL lame_set_bWriteVbrTag(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isBWriteVbrTag()"><!-- --></A><H3>
isBWriteVbrTag</H3>
<PRE>
boolean <B>isBWriteVbrTag</B>()</PRE>
<DL>
<DD>1 = write a Xing VBR header frame.
      default = 1
      this variable must have been added by a Hungarian notation Windows programmer :-)


 <pre>int CDECL lame_get_bWriteVbrTag(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDecodeOnly(boolean)"><!-- --></A><H3>
setDecodeOnly</H3>
<PRE>
void <B>setDecodeOnly</B>(boolean&nbsp;deconly)</PRE>
<DL>
<DD>1=decode only.  use lame/mpglib to convert mp3/ogg to wav.  default=0 

 <pre>int CDECL lame_set_decode_only(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDecodeOnly()"><!-- --></A><H3>
isDecodeOnly</H3>
<PRE>
boolean <B>isDecodeOnly</B>()</PRE>
<DL>
<DD>1=decode only.  use lame/mpglib to convert mp3/ogg to wav.  default=0 

 <pre>int CDECL lame_get_decode_only(lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOgg(boolean)"><!-- --></A><H3>
setOgg</H3>
<PRE>
void <B>setOgg</B>(boolean&nbsp;ogg)</PRE>
<DL>
<DD>1=encode a Vorbis .ogg file.  default=0 
 DEPRECATED

 <pre>int CDECL lame_set_ogg(lame_global_flags*, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isOgg()"><!-- --></A><H3>
isOgg</H3>
<PRE>
boolean <B>isOgg</B>()</PRE>
<DL>
<DD>1=encode a Vorbis .ogg file.  default=0 
 DEPRECATED

 <pre>int CDECL lame_get_ogg(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setQuality(int)"><!-- --></A><H3>
setQuality</H3>
<PRE>
void <B>setQuality</B>(int&nbsp;quality)</PRE>
<DL>
<DD>internal algorithm selection.  True quality is determined by the bitrate
      but this variable will effect quality by selecting expensive or cheap algorithms.
      quality=0..9.  0=best (very slow).  9=worst.
      recommended:  2     near-best quality, not too slow
                    5     good quality, fast
                    7     ok quality, really fast

 <pre>int CDECL lame_set_quality(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getQuality()"><!-- --></A><H3>
getQuality</H3>
<PRE>
int <B>getQuality</B>()</PRE>
<DL>
<DD>internal algorithm selection.  True quality is determined by the bitrate
      but this variable will effect quality by selecting expensive or cheap algorithms.
      quality=0..9.  0=best (very slow).  9=worst.
      recommended:  2     near-best quality, not too slow
                    5     good quality, fast
                    7     ok quality, really fast     

 <pre>int CDECL lame_get_quality(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMode(int)"><!-- --></A><H3>
setMode</H3>
<PRE>
void <B>setMode</B>(int&nbsp;mpeg_mode)</PRE>
<DL>
<DD>mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
      default: lame picks based on compression ration and input channels

 <pre>int CDECL lame_set_mode(lame_global_flags *, MPEG_mode);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMode()"><!-- --></A><H3>
getMode</H3>
<PRE>
int <B>getMode</B>()</PRE>
<DL>
<DD>mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
      default: lame picks based on compression ration and input channels     

 <pre>MPEG_mode CDECL lame_get_mode(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setModeAutoms(int)"><!-- --></A><H3>
setModeAutoms</H3>
<PRE>
void <B>setModeAutoms</B>(int&nbsp;mode)</PRE>
<DL>
<DD>mode_automs.  Use a M/S mode with a switching threshold based on
      compression ratio
      DEPRECATED

 <pre>int CDECL lame_set_mode_automs(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getModeAutoms()"><!-- --></A><H3>
getModeAutoms</H3>
<PRE>
int <B>getModeAutoms</B>()</PRE>
<DL>
<DD>mode_automs.  Use a M/S mode with a switching threshold based on
      compression ratio
      DEPRECATED

 <pre>int CDECL lame_get_mode_automs(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setForceMs(boolean)"><!-- --></A><H3>
setForceMs</H3>
<PRE>
void <B>setForceMs</B>(boolean&nbsp;force)</PRE>
<DL>
<DD>force_ms.  Force M/S for all frames.  For testing only.
      default = 0 (disabled)

 <pre>int CDECL lame_set_force_ms(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isForceMs()"><!-- --></A><H3>
isForceMs</H3>
<PRE>
boolean <B>isForceMs</B>()</PRE>
<DL>
<DD>force_ms.  Force M/S for all frames.  For testing only.
      default = 0 (disabled)

 <pre>int CDECL lame_get_force_ms(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFreeFormat(boolean)"><!-- --></A><H3>
setFreeFormat</H3>
<PRE>
void <B>setFreeFormat</B>(boolean&nbsp;free)</PRE>
<DL>
<DD>use free_format?  default = 0 (disabled) 

       <pre>int CDECL lame_set_free_format(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isFreeFormat()"><!-- --></A><H3>
isFreeFormat</H3>
<PRE>
boolean <B>isFreeFormat</B>()</PRE>
<DL>
<DD>use free_format?  default = 0 (disabled) 

       <pre>int CDECL lame_get_free_format(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFindReplayGain(boolean)"><!-- --></A><H3>
setFindReplayGain</H3>
<PRE>
void <B>setFindReplayGain</B>(boolean&nbsp;repGain)</PRE>
<DL>
<DD>perform ReplayGain analysis?  default = 0 (disabled) 

 <pre>int CDECL lame_set_findReplayGain(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isFindReplayGain()"><!-- --></A><H3>
isFindReplayGain</H3>
<PRE>
boolean <B>isFindReplayGain</B>()</PRE>
<DL>
<DD>perform ReplayGain analysis?  default = 0 (disabled) 

 <pre>int CDECL lame_get_findReplayGain(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDecodeOnTheFly(boolean)"><!-- --></A><H3>
setDecodeOnTheFly</H3>
<PRE>
void <B>setDecodeOnTheFly</B>(boolean&nbsp;onthefly)</PRE>
<DL>
<DD>decode on the fly. Search for the peak sample. If the ReplayGain
 analysis is enabled then perform the analysis on the decoded data
 stream. default = 0 (disabled) 
 NOTE: if this option is set the build-in decoder should not be used 

 <pre>int CDECL lame_set_decode_on_the_fly(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDecodeOnTheFly()"><!-- --></A><H3>
isDecodeOnTheFly</H3>
<PRE>
boolean <B>isDecodeOnTheFly</B>()</PRE>
<DL>
<DD>decode on the fly. Search for the peak sample. If the ReplayGain
 analysis is enabled then perform the analysis on the decoded data
 stream. default = 0 (disabled) 
 NOTE: if this option is set the build-in decoder should not be used 

 <pre>int CDECL lame_get_decode_on_the_fly(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setReplayGainInput(boolean)"><!-- --></A><H3>
setReplayGainInput</H3>
<PRE>
void <B>setReplayGainInput</B>(boolean&nbsp;repGain)</PRE>
<DL>
<DD>DEPRECATED: now does the same as lame_set_findReplayGain() 
       default = 0 (disabled) 

 <pre>int CDECL lame_set_ReplayGain_input(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isReplayGainInput()"><!-- --></A><H3>
isReplayGainInput</H3>
<PRE>
boolean <B>isReplayGainInput</B>()</PRE>
<DL>
<DD>DEPRECATED: now does the same as lame_set_findReplayGain() 
       default = 0 (disabled) 

 <pre>int CDECL lame_get_ReplayGain_input(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setReplayGainDecode(boolean)"><!-- --></A><H3>
setReplayGainDecode</H3>
<PRE>
void <B>setReplayGainDecode</B>(boolean&nbsp;repGain)</PRE>
<DL>
<DD>DEPRECATED: now does the same as 
       lame_set_decode_on_the_fly() && lame_set_findReplayGain()
       default = 0 (disabled) 

 <pre>int CDECL lame_set_ReplayGain_decode(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isReplayGainDecode()"><!-- --></A><H3>
isReplayGainDecode</H3>
<PRE>
boolean <B>isReplayGainDecode</B>()</PRE>
<DL>
<DD>DEPRECATED: now does the same as 
       lame_set_decode_on_the_fly() && lame_set_findReplayGain()
       default = 0 (disabled) 

 <pre>int CDECL lame_get_ReplayGain_decode(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFindPeakSample(boolean)"><!-- --></A><H3>
setFindPeakSample</H3>
<PRE>
void <B>setFindPeakSample</B>(boolean&nbsp;findPeak)</PRE>
<DL>
<DD>DEPRECATED: now does the same as lame_set_decode_on_the_fly() 
       default = 0 (disabled) 

 <pre>int CDECL lame_set_findPeakSample(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isFindPeakSample()"><!-- --></A><H3>
isFindPeakSample</H3>
<PRE>
boolean <B>isFindPeakSample</B>()</PRE>
<DL>
<DD>DEPRECATED: now does the same as lame_set_decode_on_the_fly() 
       default = 0 (disabled) 

 <pre>int CDECL lame_get_findPeakSample(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNogapTotal(int)"><!-- --></A><H3>
setNogapTotal</H3>
<PRE>
void <B>setNogapTotal</B>(int&nbsp;total)</PRE>
<DL>
<DD>counter for gapless encoding 

 <pre>int CDECL lame_set_nogap_total(lame_global_flags*, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNogapTotal()"><!-- --></A><H3>
getNogapTotal</H3>
<PRE>
int <B>getNogapTotal</B>()</PRE>
<DL>
<DD>counter for gapless encoding 

 <pre>int CDECL lame_get_nogap_total(const lame_global_flags*);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNogapCurrentIndex(int)"><!-- --></A><H3>
setNogapCurrentIndex</H3>
<PRE>
void <B>setNogapCurrentIndex</B>(int&nbsp;currindex)</PRE>
<DL>
<DD>counter for gapless encoding 

 <pre>int CDECL lame_set_nogap_currentindex(lame_global_flags* , int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNogapCurrentindex()"><!-- --></A><H3>
getNogapCurrentindex</H3>
<PRE>
int <B>getNogapCurrentindex</B>()</PRE>
<DL>
<DD>counter for gapless encoding 

 <pre>int CDECL lame_get_nogap_currentindex(const lame_global_flags*);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setErrorf(lame.std.LameMsgCallback)"><!-- --></A><H3>
setErrorf</H3>
<PRE>
void <B>setErrorf</B>(<A HREF="../../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</PRE>
<DL>
<DD>OPTIONAL:
 Set printf like error/debug/message reporting functions.
 The second argument has to be a pointer to a function which looks like
   void my_debugf(const char *format, va_list ap)
   {
       (void) vfprintf(stdout, format, ap);
   }
 If you use NULL as the value of the pointer in the set function, the
 lame buildin function will be used (prints to stderr).
 To quiet any output you have to replace the body of the example function
 with just "return;" and use it in the set function.

 <pre>int CDECL lame_set_errorf(lame_global_flags *,
                              void (*func)(const char *, va_list));</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDebugf(lame.std.LameMsgCallback)"><!-- --></A><H3>
setDebugf</H3>
<PRE>
void <B>setDebugf</B>(<A HREF="../../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</PRE>
<DL>
<DD>OPTIONAL:
 Set printf like error/debug/message reporting functions.
 The second argument has to be a pointer to a function which looks like
   void my_debugf(const char *format, va_list ap)
   {
       (void) vfprintf(stdout, format, ap);
   }
 If you use NULL as the value of the pointer in the set function, the
 lame buildin function will be used (prints to stderr).
 To quiet any output you have to replace the body of the example function
 with just "return;" and use it in the set function.

 <pre>int CDECL lame_set_debugf(lame_global_flags *,
                              void (*func)(const char *, va_list));</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMsgf(lame.std.LameMsgCallback)"><!-- --></A><H3>
setMsgf</H3>
<PRE>
void <B>setMsgf</B>(<A HREF="../../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</PRE>
<DL>
<DD>OPTIONAL:
 Set printf like error/debug/message reporting functions.
 The second argument has to be a pointer to a function which looks like
   void my_debugf(const char *format, va_list ap)
   {
       (void) vfprintf(stdout, format, ap);
   }
 If you use NULL as the value of the pointer in the set function, the
 lame buildin function will be used (prints to stderr).
 To quiet any output you have to replace the body of the example function
 with just "return;" and use it in the set function.

 <pre>int CDECL lame_set_msgf(lame_global_flags *,
                              void (*func)(const char *, va_list));</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBrate(int)"><!-- --></A><H3>
setBrate</H3>
<PRE>
void <B>setBrate</B>(int&nbsp;brate)</PRE>
<DL>
<DD>set one of brate compression ratio.  default is compression ratio of 11.  

 <pre>int CDECL lame_set_brate(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBrate()"><!-- --></A><H3>
getBrate</H3>
<PRE>
int <B>getBrate</B>()</PRE>
<DL>
<DD>set one of brate compression ratio.  default is compression ratio of 11.  

 <pre>int CDECL lame_get_brate(const lame_global_flags *);
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCompressionRatio(float)"><!-- --></A><H3>
setCompressionRatio</H3>
<PRE>
void <B>setCompressionRatio</B>(float&nbsp;ratio)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCompressionRatio()"><!-- --></A><H3>
getCompressionRatio</H3>
<PRE>
float <B>getCompressionRatio</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPreset(int)"><!-- --></A><H3>
setPreset</H3>
<PRE>
void <B>setPreset</B>(int&nbsp;preset)</PRE>
<DL>
<DD><pre>int CDECL lame_set_preset( lame_global_flags*  gfp, int );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAsmOptimizations(int, int)"><!-- --></A><H3>
setAsmOptimizations</H3>
<PRE>
void <B>setAsmOptimizations</B>(int&nbsp;param1,
                         int&nbsp;param2)</PRE>
<DL>
<DD><pre>int CDECL lame_set_asm_optimizations( lame_global_flags*  gfp, int, int );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCopyright(boolean)"><!-- --></A><H3>
setCopyright</H3>
<PRE>
void <B>setCopyright</B>(boolean&nbsp;cprght)</PRE>
<DL>
<DD>mark as copyright.  default=0 

       <pre>int CDECL lame_set_copyright(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isCopyright()"><!-- --></A><H3>
isCopyright</H3>
<PRE>
boolean <B>isCopyright</B>()</PRE>
<DL>
<DD>mark as copyright.  default=0 

       <pre>int CDECL lame_get_copyright(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOriginal(boolean)"><!-- --></A><H3>
setOriginal</H3>
<PRE>
void <B>setOriginal</B>(boolean&nbsp;original)</PRE>
<DL>
<DD>mark as original.  default=1 

       <pre>int CDECL lame_set_original(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isOriginal()"><!-- --></A><H3>
isOriginal</H3>
<PRE>
boolean <B>isOriginal</B>()</PRE>
<DL>
<DD>mark as original.  default=1      

       <pre>int CDECL lame_get_original(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setErrorProtection(boolean)"><!-- --></A><H3>
setErrorProtection</H3>
<PRE>
void <B>setErrorProtection</B>(boolean&nbsp;prot)</PRE>
<DL>
<DD>error_protection.  Use 2 bytes from each frame for CRC checksum. default=0

       <pre>int CDECL lame_set_error_protection(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isErrorProtection()"><!-- --></A><H3>
isErrorProtection</H3>
<PRE>
boolean <B>isErrorProtection</B>()</PRE>
<DL>
<DD>error_protection.  Use 2 bytes from each frame for CRC checksum. default=0     

       <pre>int CDECL lame_get_error_protection(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPaddingType(int)"><!-- --></A><H3>
setPaddingType</H3>
<PRE>
void <B>setPaddingType</B>(int&nbsp;padding_type)</PRE>
<DL>
<DD>padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default)

       <pre>int CDECL lame_set_padding_type(lame_global_flags *, Padding_type);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPaddingType()"><!-- --></A><H3>
getPaddingType</H3>
<PRE>
int <B>getPaddingType</B>()</PRE>
<DL>
<DD>padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default)    

       <pre>Padding_type CDECL lame_get_padding_type(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExtension(int)"><!-- --></A><H3>
setExtension</H3>
<PRE>
void <B>setExtension</B>(int&nbsp;ext)</PRE>
<DL>
<DD>MP3 'private extension' bit  Meaningless.  default=0 

 <pre>int CDECL lame_set_extension(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getExtension()"><!-- --></A><H3>
getExtension</H3>
<PRE>
int <B>getExtension</B>()</PRE>
<DL>
<DD>MP3 'private extension' bit  Meaningless.  default=0 

 <pre>int CDECL lame_get_extension(const lame_global_flags *); </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setStrictISO(boolean)"><!-- --></A><H3>
setStrictISO</H3>
<PRE>
void <B>setStrictISO</B>(boolean&nbsp;iso)</PRE>
<DL>
<DD>enforce strict ISO compliance.  default=0 

 <pre>int CDECL lame_set_strict_ISO(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isStrictISO()"><!-- --></A><H3>
isStrictISO</H3>
<PRE>
boolean <B>isStrictISO</B>()</PRE>
<DL>
<DD>enforce strict ISO compliance.  default=0 

 <pre>int CDECL lame_get_strict_ISO(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDisableReservoir(boolean)"><!-- --></A><H3>
setDisableReservoir</H3>
<PRE>
void <B>setDisableReservoir</B>(boolean&nbsp;preset)</PRE>
<DL>
<DD>disable the bit reservoir. For testing only. default=0

       <pre>int CDECL lame_set_disable_reservoir(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDisableReservoir()"><!-- --></A><H3>
isDisableReservoir</H3>
<PRE>
boolean <B>isDisableReservoir</B>()</PRE>
<DL>
<DD>disable the bit reservoir. For testing only. default=0     

       <pre>int CDECL lame_get_disable_reservoir(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setQuantComp(int)"><!-- --></A><H3>
setQuantComp</H3>
<PRE>
void <B>setQuantComp</B>(int&nbsp;quant)</PRE>
<DL>
<DD>select a different "best quantization" function. default=0  

       <pre>int CDECL lame_set_quant_comp(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getQuantComp()"><!-- --></A><H3>
getQuantComp</H3>
<PRE>
int <B>getQuantComp</B>()</PRE>
<DL>
<DD>select a different "best quantization" function. default=0  

       <pre>int CDECL lame_get_quant_comp(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setQuantCompShort(int)"><!-- --></A><H3>
setQuantCompShort</H3>
<PRE>
void <B>setQuantCompShort</B>(int&nbsp;quant)</PRE>
<DL>
<DD>select a different "best quantization" function. default=0  

       <pre>int CDECL lame_set_quant_comp_short(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getQuantCompShort()"><!-- --></A><H3>
getQuantCompShort</H3>
<PRE>
int <B>getQuantCompShort</B>()</PRE>
<DL>
<DD>select a different "best quantization" function. default=0  

       <pre>int CDECL lame_get_quant_comp_short(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExperimentalX(int)"><!-- --></A><H3>
setExperimentalX</H3>
<PRE>
void <B>setExperimentalX</B>(int&nbsp;x)</PRE>
<DL>
<DD><pre>int CDECL lame_set_experimentalX(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getExperimentalX()"><!-- --></A><H3>
getExperimentalX</H3>
<PRE>
int <B>getExperimentalX</B>()</PRE>
<DL>
<DD><pre>int CDECL lame_get_experimentalX(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExperimentalY(int)"><!-- --></A><H3>
setExperimentalY</H3>
<PRE>
void <B>setExperimentalY</B>(int&nbsp;y)</PRE>
<DL>
<DD>another experimental option.  for testing only 

 <pre>int CDECL lame_set_experimentalY(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getExperimentalY()"><!-- --></A><H3>
getExperimentalY</H3>
<PRE>
int <B>getExperimentalY</B>()</PRE>
<DL>
<DD>another experimental option.  for testing only 

 <pre>int CDECL lame_get_experimentalY(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExperimentalZ(int)"><!-- --></A><H3>
setExperimentalZ</H3>
<PRE>
void <B>setExperimentalZ</B>(int&nbsp;z)</PRE>
<DL>
<DD>another experimental option.  for testing only 

 <pre>int CDECL lame_set_experimentalZ(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getExperimentalZ()"><!-- --></A><H3>
getExperimentalZ</H3>
<PRE>
int <B>getExperimentalZ</B>()</PRE>
<DL>
<DD>another experimental option.  for testing only 

 <pre>int CDECL lame_get_experimentalZ(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExpNspsytune(int)"><!-- --></A><H3>
setExpNspsytune</H3>
<PRE>
void <B>setExpNspsytune</B>(int&nbsp;tune)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getExpNspsytune()"><!-- --></A><H3>
getExpNspsytune</H3>
<PRE>
int <B>getExpNspsytune</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMsfix(double)"><!-- --></A><H3>
setMsfix</H3>
<PRE>
void <B>setMsfix</B>(double&nbsp;msfix)</PRE>
<DL>
<DD><pre>void CDECL lame_set_msfix(lame_global_flags *, double);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMsfix()"><!-- --></A><H3>
getMsfix</H3>
<PRE>
float <B>getMsfix</B>()</PRE>
<DL>
<DD><pre>float CDECL lame_get_msfix(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExpNspsytune2Int(int, int)"><!-- --></A><H3>
setExpNspsytune2Int</H3>
<PRE>
int <B>setExpNspsytune2Int</B>(int&nbsp;p1,
                        int&nbsp;p2)</PRE>
<DL>
<DD><pre>int lame_set_exp_nspsytune2_int( lame_global_flags*, int, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExpNspsytune2Real(int, float)"><!-- --></A><H3>
setExpNspsytune2Real</H3>
<PRE>
float <B>setExpNspsytune2Real</B>(int&nbsp;p1,
                           float&nbsp;p2)</PRE>
<DL>
<DD><pre>float lame_set_exp_nspsytune2_real( lame_global_flags*, int, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExpNspsytune2Pointer(int, int)"><!-- --></A><H3>
setExpNspsytune2Pointer</H3>
<PRE>
int <B>setExpNspsytune2Pointer</B>(int&nbsp;p1,
                            int&nbsp;p2)</PRE>
<DL>
<DD><pre>void * lame_set_exp_nspsytune2_pointer( lame_global_flags*, int, void *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setVBR(int)"><!-- --></A><H3>
setVBR</H3>
<PRE>
void <B>setVBR</B>(int&nbsp;vbr_mode)</PRE>
<DL>
<DD>Types of VBR.  default = vbr_off = CBR 

 <pre>int CDECL lame_set_VBR(lame_global_flags *, vbr_mode);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVBR()"><!-- --></A><H3>
getVBR</H3>
<PRE>
int <B>getVBR</B>()</PRE>
<DL>
<DD>Types of VBR.  default = vbr_off = CBR 
     
 <pre>vbr_mode CDECL lame_get_VBR(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setVBRQ(int)"><!-- --></A><H3>
setVBRQ</H3>
<PRE>
void <B>setVBRQ</B>(int&nbsp;level)</PRE>
<DL>
<DD>VBR quality level.  0=highest  9=lowest  

        <pre>int CDECL lame_set_VBR_q(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVBRq()"><!-- --></A><H3>
getVBRq</H3>
<PRE>
int <B>getVBRq</B>()</PRE>
<DL>
<DD>VBR quality level.  0=highest  9=lowest
     
        <pre>int CDECL lame_get_VBR_q(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setVBRMeanBitrateKbps(int)"><!-- --></A><H3>
setVBRMeanBitrateKbps</H3>
<PRE>
void <B>setVBRMeanBitrateKbps</B>(int&nbsp;bitrate)</PRE>
<DL>
<DD>Ignored except for VBR=vbr_abr (ABR mode) 

        <pre>int CDECL lame_set_VBR_mean_bitrate_kbps(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVBRMeanBitrateKbps()"><!-- --></A><H3>
getVBRMeanBitrateKbps</H3>
<PRE>
int <B>getVBRMeanBitrateKbps</B>()</PRE>
<DL>
<DD>Ignored except for VBR=vbr_abr (ABR mode)     

        <pre>int CDECL lame_get_VBR_mean_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setVBRMinBitrateKbps(int)"><!-- --></A><H3>
setVBRMinBitrateKbps</H3>
<PRE>
void <B>setVBRMinBitrateKbps</B>(int&nbsp;bitrate)</PRE>
<DL>
<DD><pre>int CDECL lame_set_VBR_min_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVBRMinBitrateKbps()"><!-- --></A><H3>
getVBRMinBitrateKbps</H3>
<PRE>
int <B>getVBRMinBitrateKbps</B>()</PRE>
<DL>
<DD><pre>int CDECL lame_get_VBR_min_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setVBRMaxBitrateKbps(int)"><!-- --></A><H3>
setVBRMaxBitrateKbps</H3>
<PRE>
void <B>setVBRMaxBitrateKbps</B>(int&nbsp;bitrate)</PRE>
<DL>
<DD><pre>int CDECL lame_set_VBR_max_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVBRMaxBitrateKbps()"><!-- --></A><H3>
getVBRMaxBitrateKbps</H3>
<PRE>
int <B>getVBRMaxBitrateKbps</B>()</PRE>
<DL>
<DD><pre>int CDECL lame_get_VBR_max_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setVBRHardMin(boolean)"><!-- --></A><H3>
setVBRHardMin</H3>
<PRE>
void <B>setVBRHardMin</B>(boolean&nbsp;vbr)</PRE>
<DL>
<DD>1=strictly enforce VBR_min_bitrate.  Normally it will be violated for
      analog silence

 <pre>int CDECL lame_set_VBR_hard_min(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isVBRHardMin()"><!-- --></A><H3>
isVBRHardMin</H3>
<PRE>
boolean <B>isVBRHardMin</B>()</PRE>
<DL>
<DD>1=strictly enforce VBR_min_bitrate.  Normally it will be violated for
      analog silence

 <pre>int CDECL lame_get_VBR_hard_min(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPresetExpopts(int)"><!-- --></A><H3>
setPresetExpopts</H3>
<PRE>
void <B>setPresetExpopts</B>(int&nbsp;expopts)</PRE>
<DL>
<DD>for preset 

 <pre>int CDECL lame_set_preset_expopts(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLowpassfreq(int)"><!-- --></A><H3>
setLowpassfreq</H3>
<PRE>
void <B>setLowpassfreq</B>(int&nbsp;freq)</PRE>
<DL>
<DD>freq in Hz to apply lowpass. Default = 0 = lame chooses.  -1 = disabled 

 <pre>int CDECL lame_set_lowpassfreq(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLowpassfreq()"><!-- --></A><H3>
getLowpassfreq</H3>
<PRE>
int <B>getLowpassfreq</B>()</PRE>
<DL>
<DD>freq in Hz to apply lowpass. Default = 0 = lame chooses.  -1 = disabled 

 <pre>int CDECL lame_get_lowpassfreq(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLowpasswidth(int)"><!-- --></A><H3>
setLowpasswidth</H3>
<PRE>
void <B>setLowpasswidth</B>(int&nbsp;width)</PRE>
<DL>
<DD>width of transition band, in Hz.  Default = one polyphase filter band 

 <pre>int CDECL lame_set_lowpasswidth(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLowpasswidth()"><!-- --></A><H3>
getLowpasswidth</H3>
<PRE>
int <B>getLowpasswidth</B>()</PRE>
<DL>
<DD>width of transition band, in Hz.  Default = one polyphase filter band 

 <pre>int CDECL lame_get_lowpasswidth(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setHighpassfreq(int)"><!-- --></A><H3>
setHighpassfreq</H3>
<PRE>
void <B>setHighpassfreq</B>(int&nbsp;freq)</PRE>
<DL>
<DD>freq in Hz to apply highpass. Default = 0 = lame chooses.  -1 = disabled 

 <pre>int CDECL lame_set_highpassfreq(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getHighpassfreq()"><!-- --></A><H3>
getHighpassfreq</H3>
<PRE>
int <B>getHighpassfreq</B>()</PRE>
<DL>
<DD>freq in Hz to apply highpass. Default = 0 = lame chooses.  -1 = disabled 

 <pre>int CDECL lame_get_highpassfreq(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setHighpasswidth(int)"><!-- --></A><H3>
setHighpasswidth</H3>
<PRE>
void <B>setHighpasswidth</B>(int&nbsp;width)</PRE>
<DL>
<DD>width of transition band, in Hz.  Default = one polyphase filter band 

 <pre>int CDECL lame_set_highpasswidth(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getHighpasswidth()"><!-- --></A><H3>
getHighpasswidth</H3>
<PRE>
int <B>getHighpasswidth</B>()</PRE>
<DL>
<DD>width of transition band, in Hz.  Default = one polyphase filter band 

 <pre>int CDECL lame_get_highpasswidth(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setATHonly(boolean)"><!-- --></A><H3>
setATHonly</H3>
<PRE>
void <B>setATHonly</B>(boolean&nbsp;athOnly)</PRE>
<DL>
<DD>only use ATH for masking 

 <pre>int CDECL lame_set_ATHonly(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isATHonly()"><!-- --></A><H3>
isATHonly</H3>
<PRE>
boolean <B>isATHonly</B>()</PRE>
<DL>
<DD>only use ATH for masking 

 <pre>int CDECL lame_get_ATHonly(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setATHshort(boolean)"><!-- --></A><H3>
setATHshort</H3>
<PRE>
void <B>setATHshort</B>(boolean&nbsp;athShort)</PRE>
<DL>
<DD>only use ATH for short blocks 

 <pre>int CDECL lame_set_ATHshort(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isATHshort()"><!-- --></A><H3>
isATHshort</H3>
<PRE>
boolean <B>isATHshort</B>()</PRE>
<DL>
<DD>only use ATH for short blocks 

 <pre>int CDECL lame_get_ATHshort(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNoATH(boolean)"><!-- --></A><H3>
setNoATH</H3>
<PRE>
void <B>setNoATH</B>(boolean&nbsp;noATH)</PRE>
<DL>
<DD>disable ATH 

 <pre>int CDECL lame_set_noATH(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isNoATH()"><!-- --></A><H3>
isNoATH</H3>
<PRE>
boolean <B>isNoATH</B>()</PRE>
<DL>
<DD>disable ATH 

 <pre>int CDECL lame_get_noATH(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setATHtype(int)"><!-- --></A><H3>
setATHtype</H3>
<PRE>
void <B>setATHtype</B>(int&nbsp;ATHType)</PRE>
<DL>
<DD>select ATH formula 

 <pre>int CDECL lame_set_ATHtype(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getATHtype()"><!-- --></A><H3>
getATHtype</H3>
<PRE>
int <B>getATHtype</B>()</PRE>
<DL>
<DD>select ATH formula 

 <pre>int CDECL lame_get_ATHtype(lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setATHlower(float)"><!-- --></A><H3>
setATHlower</H3>
<PRE>
void <B>setATHlower</B>(float&nbsp;ATHLower)</PRE>
<DL>
<DD>lower ATH by this many db 

 <pre>int CDECL lame_set_ATHlower(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getATHlower()"><!-- --></A><H3>
getATHlower</H3>
<PRE>
float <B>getATHlower</B>()</PRE>
<DL>
<DD>lower ATH by this many db 

 <pre>floag CDECL lame_get_ATHlower(lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAthaaType(int)"><!-- --></A><H3>
setAthaaType</H3>
<PRE>
void <B>setAthaaType</B>(int&nbsp;ATHadjust)</PRE>
<DL>
<DD>select ATH adaptive adjustment type 

 <pre>int CDECL lame_set_athaa_type( lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAthaaType()"><!-- --></A><H3>
getAthaaType</H3>
<PRE>
int <B>getAthaaType</B>()</PRE>
<DL>
<DD>select ATH adaptive adjustment type 

 <pre>int CDECL lame_get_athaa_type( const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAthaaLoudapprox(int)"><!-- --></A><H3>
setAthaaLoudapprox</H3>
<PRE>
void <B>setAthaaLoudapprox</B>(int&nbsp;loud)</PRE>
<DL>
<DD>select the loudness approximation used by the ATH adaptive auto-leveling  

 <pre>int CDECL lame_set_athaa_loudapprox( lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAthaaLoudapprox()"><!-- --></A><H3>
getAthaaLoudapprox</H3>
<PRE>
int <B>getAthaaLoudapprox</B>()</PRE>
<DL>
<DD>select the loudness approximation used by the ATH adaptive auto-leveling  

 <pre>int CDECL lame_get_athaa_loudapprox( const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAthaaSensitivity(float)"><!-- --></A><H3>
setAthaaSensitivity</H3>
<PRE>
void <B>setAthaaSensitivity</B>(float&nbsp;sen)</PRE>
<DL>
<DD>adjust (in dB) the point below which adaptive ATH level adjustment occurs 

 <pre>int CDECL lame_set_athaa_sensitivity( lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAthaaSensitivity()"><!-- --></A><H3>
getAthaaSensitivity</H3>
<PRE>
float <B>getAthaaSensitivity</B>()</PRE>
<DL>
<DD>adjust (in dB) the point below which adaptive ATH level adjustment occurs 

 <pre>float CDECL lame_get_athaa_sensitivity( const lame_global_flags* );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCwlimit(int)"><!-- --></A><H3>
setCwlimit</H3>
<PRE>
void <B>setCwlimit</B>(int&nbsp;limit)</PRE>
<DL>
<DD>predictability limit (ISO tonality formula) 

       <pre>int CDECL lame_set_cwlimit(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCwlimit()"><!-- --></A><H3>
getCwlimit</H3>
<PRE>
int <B>getCwlimit</B>()</PRE>
<DL>
<DD>predictability limit (ISO tonality formula)

       <pre>int CDECL lame_get_cwlimit(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAllowDiffShort(int)"><!-- --></A><H3>
setAllowDiffShort</H3>
<PRE>
void <B>setAllowDiffShort</B>(int&nbsp;allow)</PRE>
<DL>
<DD>allow blocktypes to differ between channels?
      default: 0 for jstereo, 1 for stereo

 <pre>int CDECL lame_set_allow_diff_short(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAllowDiffShort()"><!-- --></A><H3>
getAllowDiffShort</H3>
<PRE>
int <B>getAllowDiffShort</B>()</PRE>
<DL>
<DD>allow blocktypes to differ between channels?
      default: 0 for jstereo, 1 for stereo

 <pre>int CDECL lame_get_allow_diff_short(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUseTemporal(boolean)"><!-- --></A><H3>
setUseTemporal</H3>
<PRE>
void <B>setUseTemporal</B>(boolean&nbsp;maskEffect)</PRE>
<DL>
<DD>use temporal masking effect (default = 1) 

 <pre>int CDECL lame_set_useTemporal(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isUseTemporal()"><!-- --></A><H3>
isUseTemporal</H3>
<PRE>
boolean <B>isUseTemporal</B>()</PRE>
<DL>
<DD>use temporal masking effect (default = 1) 

 <pre>int CDECL lame_get_useTemporal(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setInterChRatio(float)"><!-- --></A><H3>
setInterChRatio</H3>
<PRE>
void <B>setInterChRatio</B>(float&nbsp;interChRatio)</PRE>
<DL>
<DD>use temporal masking effect (default = 1) 

 <pre>int CDECL lame_set_interChRatio(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInterChRatio()"><!-- --></A><H3>
getInterChRatio</H3>
<PRE>
float <B>getInterChRatio</B>()</PRE>
<DL>
<DD>use temporal masking effect (default = 1) 

 <pre>float CDECL lame_get_interChRatio(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNoShortBlocks(boolean)"><!-- --></A><H3>
setNoShortBlocks</H3>
<PRE>
void <B>setNoShortBlocks</B>(boolean&nbsp;noShort)</PRE>
<DL>
<DD>disable short blocks 

       <pre>int CDECL lame_set_no_short_blocks(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isNoShortBlocks()"><!-- --></A><H3>
isNoShortBlocks</H3>
<PRE>
boolean <B>isNoShortBlocks</B>()</PRE>
<DL>
<DD>disable short blocks 

       <pre>int CDECL lame_get_no_short_blocks(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setForceShortBlocks(boolean)"><!-- --></A><H3>
setForceShortBlocks</H3>
<PRE>
void <B>setForceShortBlocks</B>(boolean&nbsp;force)</PRE>
<DL>
<DD>force short blocks 

 <pre>int CDECL lame_set_force_short_blocks(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isForceShortBlocks()"><!-- --></A><H3>
isForceShortBlocks</H3>
<PRE>
boolean <B>isForceShortBlocks</B>()</PRE>
<DL>
<DD>force short blocks 

 <pre>int CDECL lame_get_force_short_blocks(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setEmphasis(boolean)"><!-- --></A><H3>
setEmphasis</H3>
<PRE>
void <B>setEmphasis</B>(boolean&nbsp;emph)</PRE>
<DL>
<DD>Input PCM is emphased PCM (for instance from one of the rarely
       emphased CDs), it is STRONGLY not recommended to use this, because
       psycho does not take it into account, and last but not least many decoders
       ignore these bits      

 <pre>int CDECL lame_set_emphasis(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isEmphasis()"><!-- --></A><H3>
isEmphasis</H3>
<PRE>
boolean <B>isEmphasis</B>()</PRE>
<DL>
<DD>Input PCM is emphased PCM (for instance from one of the rarely
       emphased CDs), it is STRONGLY not recommended to use this, because
       psycho does not take it into account, and last but not least many decoders
       ignore these bits      

 <pre>int CDECL lame_get_emphasis(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVersion()"><!-- --></A><H3>
getVersion</H3>
<PRE>
int <B>getVersion</B>()</PRE>
<DL>
<DD>version  0=MPEG-2  1=MPEG-1  (2=MPEG-2.5)    

 <pre>int CDECL lame_get_version(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEncoderDelay()"><!-- --></A><H3>
getEncoderDelay</H3>
<PRE>
int <B>getEncoderDelay</B>()</PRE>
<DL>
<DD>encoder delay   

 <pre>int CDECL lame_get_encoder_delay(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEncoderPadding()"><!-- --></A><H3>
getEncoderPadding</H3>
<PRE>
int <B>getEncoderPadding</B>()</PRE>
<DL>
<DD>padding appended to the input to make sure decoder can fully decode
      all input.  Note that this value can only be calculated during the
      call to lame_encoder_flush().  Before lame_encoder_flush() has
      been called, the value of encoder_padding = 0.

 <pre>int CDECL lame_get_encoder_padding(const lame_global_flags *);  </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getFramesize()"><!-- --></A><H3>
getFramesize</H3>
<PRE>
int <B>getFramesize</B>()</PRE>
<DL>
<DD>size of MPEG frame 

      <pre>int CDECL lame_get_framesize(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMfSamplesToEncode()"><!-- --></A><H3>
getMfSamplesToEncode</H3>
<PRE>
int <B>getMfSamplesToEncode</B>()</PRE>
<DL>
<DD>number of PCM samples buffered, but not yet encoded to mp3 data. 

 <pre>int CDECL lame_get_mf_samples_to_encode( const lame_global_flags*  gfp );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeMP3buffer()"><!-- --></A><H3>
getSizeMP3buffer</H3>
<PRE>
int <B>getSizeMP3buffer</B>()</PRE>
<DL>
<DD>size (bytes) of mp3 data buffered, but not yet encoded.
      this is the number of bytes which would be output by a call to 
      lame_encode_flush_nogap.  NOTE: lame_encode_flush() will return
      more bytes than this because it will encode the reamining buffered
      PCM samples before flushing the mp3 buffers.

 <pre>int CDECL lame_get_size_mp3buffer( const lame_global_flags*  gfp );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getFrameNum()"><!-- --></A><H3>
getFrameNum</H3>
<PRE>
int <B>getFrameNum</B>()</PRE>
<DL>
<DD>number of frames encoded so far 

      <pre>int CDECL lame_get_frameNum(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTotalframes()"><!-- --></A><H3>
getTotalframes</H3>
<PRE>
int <B>getTotalframes</B>()</PRE>
<DL>
<DD>lame's estimate of the total number of frames to be encoded
       only valid if calling program set num_samples

 <pre>int CDECL lame_get_totalframes(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRadioGain()"><!-- --></A><H3>
getRadioGain</H3>
<PRE>
int <B>getRadioGain</B>()</PRE>
<DL>
<DD>RadioGain value. Multiplied by 10 and rounded to the nearest. 

 <pre>int CDECL lame_get_RadioGain(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAudiophileGain()"><!-- --></A><H3>
getAudiophileGain</H3>
<PRE>
int <B>getAudiophileGain</B>()</PRE>
<DL>
<DD>AudiophileGain value. Multipled by 10 and rounded to the nearest. 

      <pre>int CDECL lame_get_AudiophileGain(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPeakSample()"><!-- --></A><H3>
getPeakSample</H3>
<PRE>
float <B>getPeakSample</B>()</PRE>
<DL>
<DD>the peak sample 

      <pre>float CDECL lame_get_PeakSample(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNoclipGainChange()"><!-- --></A><H3>
getNoclipGainChange</H3>
<PRE>
int <B>getNoclipGainChange</B>()</PRE>
<DL>
<DD>Gain change required for preventing clipping. The value is correct only if 
       peak sample searching was enabled. If negative then the waveform 
       already does not clip. The value is multiplied by 10 and rounded up. 

      <pre>int CDECL lame_get_noclipGainChange(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNoclipScale()"><!-- --></A><H3>
getNoclipScale</H3>
<PRE>
float <B>getNoclipScale</B>()</PRE>
<DL>
<DD>user-specified scale factor required for preventing clipping. Value is 
       correct only if peak sample searching was enabled and no user-specified
       scaling was performed. If negative then either the waveform already does
       not clip or the value cannot be determined 

 <pre>float CDECL lame_get_noclipScale(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLameVersion()"><!-- --></A><H3>
getLameVersion</H3>
<PRE>
java.lang.String <B>getLameVersion</B>()</PRE>
<DL>
<DD>OPTIONAL:
 get the version number, in a string. of the form:  
 "3.63 (beta)" or just "3.63". 

 <pre>const char*  CDECL get_lame_version( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLameShortVersion()"><!-- --></A><H3>
getLameShortVersion</H3>
<PRE>
java.lang.String <B>getLameShortVersion</B>()</PRE>
<DL>
<DD><pre>const char*  CDECL get_lame_short_version( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLameVeryShortVersion()"><!-- --></A><H3>
getLameVeryShortVersion</H3>
<PRE>
java.lang.String <B>getLameVeryShortVersion</B>()</PRE>
<DL>
<DD><pre>const char*  CDECL get_lame_very_short_version( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPsyVersion()"><!-- --></A><H3>
getPsyVersion</H3>
<PRE>
java.lang.String <B>getPsyVersion</B>()</PRE>
<DL>
<DD><pre>const char*  CDECL get_psy_version( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLameUrl()"><!-- --></A><H3>
getLameUrl</H3>
<PRE>
java.lang.String <B>getLameUrl</B>()</PRE>
<DL>
<DD><pre>const char*  CDECL get_lame_url( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLameVersionNumerical(lame.std.lame_version_t)"><!-- --></A><H3>
getLameVersionNumerical</H3>
<PRE>
void <B>getLameVersionNumerical</B>(<A HREF="../../../lame/std/lame_version_t.html" title="class in lame.std">lame_version_t</A>&nbsp;version)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printConfig()"><!-- --></A><H3>
printConfig</H3>
<PRE>
void <B>printConfig</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printInternals()"><!-- --></A><H3>
printInternals</H3>
<PRE>
void <B>printInternals</B>()</PRE>
<DL>
<DD><pre>void CDECL lame_print_internals( const lame_global_flags *gfp);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bitrateHist(int[])"><!-- --></A><H3>
bitrateHist</H3>
<PRE>
void <B>bitrateHist</B>(int[]&nbsp;bitrate_count)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bitrateKbps(int[])"><!-- --></A><H3>
bitrateKbps</H3>
<PRE>
void <B>bitrateKbps</B>(int[]&nbsp;bitrate_kbps)</PRE>
<DL>
<DD>See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 <pre>
 void CDECL lame_bitrate_kbps( 
            const lame_global_flags *const gfp, 
            int bitrate_kbps [14] );  
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stereoModeHist(int[])"><!-- --></A><H3>
stereoModeHist</H3>
<PRE>
void <B>stereoModeHist</B>(int[]&nbsp;stereo_mode_count)</PRE>
<DL>
<DD>See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 <pre>
 void CDECL lame_stereo_mode_hist( 
            const lame_global_flags *const gfp, 
            int stereo_mode_count[4] );  
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bitrateStereoModeHist(int[][])"><!-- --></A><H3>
bitrateStereoModeHist</H3>
<PRE>
void <B>bitrateStereoModeHist</B>(int[][]&nbsp;bitrate_stmode_count)</PRE>
<DL>
<DD>See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 <pre>
 void CDECL lame_bitrate_stereo_mode_hist ( 
        const lame_global_flags * const gfp, 
        int  bitrate_stmode_count [14] [4] );
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="blockTypeHist(int[])"><!-- --></A><H3>
blockTypeHist</H3>
<PRE>
void <B>blockTypeHist</B>(int[]&nbsp;btype_count)</PRE>
<DL>
<DD>See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 <pre>
 void CDECL lame_block_type_hist (
        const lame_global_flags * const gfp, 
        int btype_count[6] );
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bitrateBlockTypeHist(int[][])"><!-- --></A><H3>
bitrateBlockTypeHist</H3>
<PRE>
void <B>bitrateBlockTypeHist</B>(int[][]&nbsp;bitrate_btype_count)</PRE>
<DL>
<DD>See <A HREF="../../../lameonj/encoder/std/EncoderConfig.html#bitrateHist(int[])"><CODE>bitrateHist(int[])</CODE></A>

 <pre>
 void CDECL lame_bitrate_block_type_hist ( 
        const lame_global_flags * const gfp, 
        int bitrate_btype_count[14][6] );
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/EncoderConfig.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../lameonj/encoder/std/Encoder.html" title="interface in lameonj.encoder.std"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../lameonj/encoder/std/GenericEncoder.html" title="interface in lameonj.encoder.std"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?lameonj/encoder/std/EncoderConfig.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="EncoderConfig.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

                
                Copyright  2006-2008 Jose Maria Arranz. All Rights Reserved.
                
            
</BODY>
</HTML>
