<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_18) on Tue Dec 14 18:46:15 CET 2010 -->
<TITLE>
Lame (LAMEOnJ v1.2, doc. version v1.0)
</TITLE>

<META NAME="date" CONTENT="2010-12-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Lame (LAMEOnJ v1.2, doc. version v1.0)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Lame.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../lame/std/FileUtil.FILE.html" title="class in lame.std"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../lame/std/lame_errorcodes_t.html" title="interface in lame.std"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?lame/std/Lame.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Lame.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
lame.std</FONT>
<BR>
Class Lame</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>lame.std.Lame</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Lame</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../lame/std/Lame.html#Lame()">Lame</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#get_lame_short_version()">get_lame_short_version</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char*  CDECL get_lame_short_version( void );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#get_lame_url()">get_lame_url</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char*  CDECL get_lame_url( void );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#get_lame_version_numerical(lame.std.lame_version_t)">get_lame_version_numerical</A></B>(<A HREF="../../lame/std/lame_version_t.html" title="class in lame.std">lame_version_t</A>&nbsp;version)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#get_lame_version()">get_lame_version</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONAL:
 get the version number, in a string. of the form:  
 "3.63 (beta)" or just "3.63".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#get_lame_very_short_version()">get_lame_very_short_version</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char*  CDECL get_lame_very_short_version( void );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#get_psy_version()">get_psy_version</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char*  CDECL get_psy_version( void );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_bitrate_block_type_hist(lame.std.lame_global_flags, int[][])">lame_bitrate_block_type_hist</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                             int[][]&nbsp;bitrate_btype_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 
 void CDECL lame_bitrate_block_type_hist ( 
        const lame_global_flags * const gfp, 
        int bitrate_btype_count[14][6] );
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])">lame_bitrate_hist</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                  int[]&nbsp;bitrate_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_bitrate_kbps(lame.std.lame_global_flags, int[])">lame_bitrate_kbps</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                  int[]&nbsp;bitrate_kbps)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 
 void CDECL lame_bitrate_kbps( 
            const lame_global_flags *const gfp, 
            int bitrate_kbps [14] );  
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_bitrate_stereo_mode_hist(lame.std.lame_global_flags, int[][])">lame_bitrate_stereo_mode_hist</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                              int[][]&nbsp;bitrate_stmode_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 
 void CDECL lame_bitrate_stereo_mode_hist ( 
        const lame_global_flags * const gfp, 
        int  bitrate_stmode_count [14] [4] );
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_block_type_hist(lame.std.lame_global_flags, int[])">lame_block_type_hist</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                     int[]&nbsp;btype_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 
 void CDECL lame_block_type_hist (
        const lame_global_flags * const gfp, 
        int btype_count[6] );
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_close(lame.std.lame_global_flags)">lame_close</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REQUIRED:
 final call to free all remaining buffers

 int  CDECL lame_close (lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode_exit()">lame_decode_exit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanup call to exit decoder  

 int CDECL lame_decode_exit(void);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode_headers(byte[], int, byte[], byte[], lame.std.mp3data_struct)">lame_decode_headers</A></B>(byte[]&nbsp;mp3buf,
                    int&nbsp;len,
                    byte[]&nbsp;pcm_l,
                    byte[]&nbsp;pcm_r,
                    <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode_headers(byte[], int, short[], short[], lame.std.mp3data_struct)">lame_decode_headers</A></B>(byte[]&nbsp;mp3buf,
                    int&nbsp;len,
                    short[]&nbsp;pcm_l,
                    short[]&nbsp;pcm_r,
                    <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;same as lame_decode, and also returns mp3 header data 

 
    int CDECL lame_decode_headers(
            unsigned char*   mp3buf,
            int              len,
            short            pcm_l[],
            short            pcm_r[],
            mp3data_struct*  mp3data );
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode_init()">lame_decode_init</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;required call to initialize decoder 
 NOTE: the decoder should not be used when encoding is performed
 with decoding on the fly 

 int CDECL lame_decode_init(void);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode(byte[], int, byte[], byte[])">lame_decode</A></B>(byte[]&nbsp;mp3buf,
            int&nbsp;len,
            byte[]&nbsp;pcm_l,
            byte[]&nbsp;pcm_r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode(byte[], int, short[], short[])">lame_decode</A></B>(byte[]&nbsp;mp3buf,
            int&nbsp;len,
            short[]&nbsp;pcm_l,
            short[]&nbsp;pcm_r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 input 1 mp3 frame, output (maybe) pcm data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode1_headers(byte[], int, byte[], byte[], lame.std.mp3data_struct)">lame_decode1_headers</A></B>(byte[]&nbsp;mp3buf,
                     int&nbsp;len,
                     byte[]&nbsp;pcm_l,
                     byte[]&nbsp;pcm_r,
                     <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode1_headers(byte[], int, short[], short[], lame.std.mp3data_struct)">lame_decode1_headers</A></B>(byte[]&nbsp;mp3buf,
                     int&nbsp;len,
                     short[]&nbsp;pcm_l,
                     short[]&nbsp;pcm_r,
                     <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;same as lame_decode1, but returns at most one frame and mp3 header data 

 
    int CDECL lame_decode1_headers(
            unsigned char*   mp3buf,
            int              len,
            short            pcm_l[],
            short            pcm_r[],
            mp3data_struct*  mp3data );
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode1_headersB(byte[], int, byte[], byte[], lame.std.mp3data_struct, com.innowhere.jnieasy.core.data.NativeInteger, com.innowhere.jnieasy.core.data.NativeInteger)">lame_decode1_headersB</A></B>(byte[]&nbsp;mp3buf,
                      int&nbsp;len,
                      byte[]&nbsp;pcm_l,
                      byte[]&nbsp;pcm_r,
                      <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data,
                      com.innowhere.jnieasy.core.data.NativeInteger&nbsp;enc_delay,
                      com.innowhere.jnieasy.core.data.NativeInteger&nbsp;enc_padding)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode1_headersB(byte[], int, short[], short[], lame.std.mp3data_struct, com.innowhere.jnieasy.core.data.NativeInteger, com.innowhere.jnieasy.core.data.NativeInteger)">lame_decode1_headersB</A></B>(byte[]&nbsp;mp3buf,
                      int&nbsp;len,
                      short[]&nbsp;pcm_l,
                      short[]&nbsp;pcm_r,
                      <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data,
                      com.innowhere.jnieasy.core.data.NativeInteger&nbsp;enc_delay,
                      com.innowhere.jnieasy.core.data.NativeInteger&nbsp;enc_padding)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;same as lame_decode1_headers, but also returns enc_delay and enc_padding
       from VBR Info tag, (-1 if no info tag was found) 

 
    int CDECL lame_decode1_headersB(
            unsigned char*   mp3buf,
            int              len,
            short            pcm_l[],
            short            pcm_r[],
            mp3data_struct*  mp3data,
            int              *enc_delay,
            int              *enc_padding ); 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode1(byte[], int, byte[], byte[])">lame_decode1</A></B>(byte[]&nbsp;mp3buf,
             int&nbsp;len,
             byte[]&nbsp;pcm_l,
             byte[]&nbsp;pcm_r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_decode1(byte[], int, short[], short[])">lame_decode1</A></B>(byte[]&nbsp;mp3buf,
             int&nbsp;len,
             short[]&nbsp;pcm_l,
             short[]&nbsp;pcm_r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;same as lame_decode, but returns at most one frame 

 
 int CDECL lame_decode1(
            unsigned char*  mp3buf,
            int             len,
            short           pcm_l[],
            short           pcm_r[] ); 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_buffer_float(lame.std.lame_global_flags, float[], float[], int, byte[], int)">lame_encode_buffer_float</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                         float[]&nbsp;buffer_l,
                         float[]&nbsp;buffer_r,
                         int&nbsp;nsamples,
                         byte[]&nbsp;mp3buf,
                         int&nbsp;mp3buf_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as lame_encode_buffer, but for 'float's.
 !!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_buffer_int(lame.std.lame_global_flags, int[], int[], int, byte[], int)">lame_encode_buffer_int</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                       int[]&nbsp;buffer_l,
                       int[]&nbsp;buffer_r,
                       int&nbsp;nsamples,
                       byte[]&nbsp;mp3buf,
                       int&nbsp;mp3buf_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_buffer_interleaved(lame.std.lame_global_flags, byte[], int, byte[], int)">lame_encode_buffer_interleaved</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                               byte[]&nbsp;pcm,
                               int&nbsp;num_samples,
                               byte[]&nbsp;mp3buf,
                               int&nbsp;mp3buf_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_buffer_interleaved(lame.std.lame_global_flags, short[], int, byte[], int)">lame_encode_buffer_interleaved</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                               short[]&nbsp;pcm,
                               int&nbsp;num_samples,
                               byte[]&nbsp;mp3buf,
                               int&nbsp;mp3buf_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as above (lame_encode_buffer), but input has L & R channel data interleaved.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_buffer_long(lame.std.lame_global_flags, int[], int[], int, byte[], int)">lame_encode_buffer_long</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                        int[]&nbsp;buffer_l,
                        int[]&nbsp;buffer_r,
                        int&nbsp;nsamples,
                        byte[]&nbsp;mp3buf,
                        int&nbsp;mp3buf_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_buffer_long2(lame.std.lame_global_flags, int[], int[], int, byte[], int)">lame_encode_buffer_long2</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                         int[]&nbsp;buffer_l,
                         int[]&nbsp;buffer_r,
                         int&nbsp;nsamples,
                         byte[]&nbsp;mp3buf,
                         int&nbsp;mp3buf_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_buffer(lame.std.lame_global_flags, byte[], byte[], int, byte[], int)">lame_encode_buffer</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                   byte[]&nbsp;buffer_l,
                   byte[]&nbsp;buffer_r,
                   int&nbsp;nsamples,
                   byte[]&nbsp;mp3buf,
                   int&nbsp;mp3buf_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_buffer(lame.std.lame_global_flags, short[], short[], int, byte[], int)">lame_encode_buffer</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                   short[]&nbsp;buffer_l,
                   short[]&nbsp;buffer_r,
                   int&nbsp;nsamples,
                   byte[]&nbsp;mp3buf,
                   int&nbsp;mp3buf_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 input pcm data, output (maybe) mp3 frames.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_flush_nogap(lame.std.lame_global_flags, byte[], int)">lame_encode_flush_nogap</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                        byte[]&nbsp;mp3buf,
                        int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_encode_flush(lame.std.lame_global_flags, byte[], int)">lame_encode_flush</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                  byte[]&nbsp;mp3buf,
                  int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 REQUIRED:
 lame_encode_flush will flush the intenal PCM buffers, padding with 
 0's to make sure the final frame is complete, and then flush
 the internal MP3 buffers, and thus may return a 
 final few mp3 frames.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_allow_diff_short(lame.std.lame_global_flags)">lame_get_allow_diff_short</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow blocktypes to differ between channels?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_analysis(lame.std.lame_global_flags)">lame_get_analysis</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=cause Lame to collect data for an MP3 frame analyzer. default=0
    
 int CDECL lame_get_analysis(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_athaa_loudapprox(lame.std.lame_global_flags)">lame_get_athaa_loudapprox</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select the loudness approximation used by the ATH adaptive auto-leveling  

 int CDECL lame_get_athaa_loudapprox( const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_athaa_sensitivity(lame.std.lame_global_flags)">lame_get_athaa_sensitivity</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adjust (in dB) the point below which adaptive ATH level adjustment occurs 

 float CDECL lame_get_athaa_sensitivity( const lame_global_flags* );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_athaa_type(lame.std.lame_global_flags)">lame_get_athaa_type</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select ATH adaptive adjustment type 

 int CDECL lame_get_athaa_type( const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_ATHlower(lame.std.lame_global_flags)">lame_get_ATHlower</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lower ATH by this many db 

 floag CDECL lame_get_ATHlower(lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_ATHonly(lame.std.lame_global_flags)">lame_get_ATHonly</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only use ATH for masking 

 int CDECL lame_get_ATHonly(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_ATHshort(lame.std.lame_global_flags)">lame_get_ATHshort</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only use ATH for short blocks 

 int CDECL lame_get_ATHshort(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_ATHtype(lame.std.lame_global_flags)">lame_get_ATHtype</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select ATH formula 

 int CDECL lame_get_ATHtype(lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_AudiophileGain(lame.std.lame_global_flags)">lame_get_AudiophileGain</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AudiophileGain value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_brate(lame.std.lame_global_flags)">lame_get_brate</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set one of brate compression ratio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_bWriteVbrTag(lame.std.lame_global_flags)">lame_get_bWriteVbrTag</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 = write a Xing VBR header frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_compression_ratio(lame.std.lame_global_flags)">lame_get_compression_ratio</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_copyright(lame.std.lame_global_flags)">lame_get_copyright</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark as copyright.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_cwlimit(lame.std.lame_global_flags)">lame_get_cwlimit</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predictability limit (ISO tonality formula) 

       int CDECL lame_get_cwlimit(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_decode_on_the_fly(lame.std.lame_global_flags)">lame_get_decode_on_the_fly</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decode on the fly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_decode_only(lame.std.lame_global_flags)">lame_get_decode_only</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=decode only.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_disable_reservoir(lame.std.lame_global_flags)">lame_get_disable_reservoir</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable the bit reservoir.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_emphasis(lame.std.lame_global_flags)">lame_get_emphasis</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Input PCM is emphased PCM (for instance from one of the rarely
       emphased CDs), it is STRONGLY not recommended to use this, because
       psycho does not take it into account, and last but not least many decoders
       ignore these bits      

 int CDECL lame_get_emphasis(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_encoder_delay(lame.std.lame_global_flags)">lame_get_encoder_delay</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encoder delay   

 int CDECL lame_get_encoder_delay(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_encoder_padding(lame.std.lame_global_flags)">lame_get_encoder_padding</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding appended to the input to make sure decoder can fully decode
      all input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_error_protection(lame.std.lame_global_flags)">lame_get_error_protection</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_protection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_exp_nspsytune(lame.std.lame_global_flags)">lame_get_exp_nspsytune</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_experimentalX(lame.std.lame_global_flags)">lame_get_experimentalX</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_get_experimentalX(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_experimentalY(lame.std.lame_global_flags)">lame_get_experimentalY</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another experimental option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_experimentalZ(lame.std.lame_global_flags)">lame_get_experimentalZ</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another experimental option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_extension(lame.std.lame_global_flags)">lame_get_extension</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MP3 'private extension' bit  Meaningless.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_findPeakSample(lame.std.lame_global_flags)">lame_get_findPeakSample</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as lame_set_decode_on_the_fly() 
       default = 0 (disabled) 

 int CDECL lame_get_findPeakSample(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_findReplayGain(lame.std.lame_global_flags)">lame_get_findReplayGain</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perform ReplayGain analysis?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_force_ms(lame.std.lame_global_flags)">lame_get_force_ms</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;force_ms.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_force_short_blocks(lame.std.lame_global_flags)">lame_get_force_short_blocks</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;force short blocks 

 int CDECL lame_get_force_short_blocks(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_frameNum(lame.std.lame_global_flags)">lame_get_frameNum</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of frames encoded so far 

      int CDECL lame_get_frameNum(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_framesize(lame.std.lame_global_flags)">lame_get_framesize</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size of MPEG frame 

      int CDECL lame_get_framesize(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_free_format(lame.std.lame_global_flags)">lame_get_free_format</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use free_format?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_highpassfreq(lame.std.lame_global_flags)">lame_get_highpassfreq</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq in Hz to apply highpass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_highpasswidth(lame.std.lame_global_flags)">lame_get_highpasswidth</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of transition band, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_in_samplerate(lame.std.lame_global_flags)">lame_get_in_samplerate</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input sample rate in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_interChRatio(lame.std.lame_global_flags)">lame_get_interChRatio</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use temporal masking effect (default = 1) 

 float CDECL lame_get_interChRatio(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_lowpassfreq(lame.std.lame_global_flags)">lame_get_lowpassfreq</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq in Hz to apply lowpass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_lowpasswidth(lame.std.lame_global_flags)">lame_get_lowpasswidth</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of transition band, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_mf_samples_to_encode(lame.std.lame_global_flags)">lame_get_mf_samples_to_encode</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of PCM samples buffered, but not yet encoded to mp3 data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_mode_automs(lame.std.lame_global_flags)">lame_get_mode_automs</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode_automs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_mode(lame.std.lame_global_flags)">lame_get_mode</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
      default: lame picks based on compression ration and input channels     

 MPEG_mode CDECL lame_get_mode(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_msfix(lame.std.lame_global_flags)">lame_get_msfix</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float CDECL lame_get_msfix(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_no_short_blocks(lame.std.lame_global_flags)">lame_get_no_short_blocks</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable short blocks 

       int CDECL lame_get_no_short_blocks(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_noATH(lame.std.lame_global_flags)">lame_get_noATH</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable ATH 

 int CDECL lame_get_noATH(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_noclipGainChange(lame.std.lame_global_flags)">lame_get_noclipGainChange</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gain change required for preventing clipping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_noclipScale(lame.std.lame_global_flags)">lame_get_noclipScale</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user-specified scale factor required for preventing clipping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_nogap_currentindex(lame.std.lame_global_flags)">lame_get_nogap_currentindex</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter for gapless encoding 

 int CDECL lame_get_nogap_currentindex(const lame_global_flags*);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_nogap_total(lame.std.lame_global_flags)">lame_get_nogap_total</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter for gapless encoding 

 int CDECL lame_get_nogap_total(const lame_global_flags*);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_num_channels(lame.std.lame_global_flags)">lame_get_num_channels</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of channels in input stream. default=2  

 int CDECL lame_get_num_channels(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_num_samples(lame.std.lame_global_flags)">lame_get_num_samples</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_ogg(lame.std.lame_global_flags)">lame_get_ogg</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=encode a Vorbis .ogg file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_original(lame.std.lame_global_flags)">lame_get_original</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark as original.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_out_samplerate(lame.std.lame_global_flags)">lame_get_out_samplerate</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      output sample rate in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_padding_type(lame.std.lame_global_flags)">lame_get_padding_type</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default)    

       Padding_type CDECL lame_get_padding_type(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_PeakSample(lame.std.lame_global_flags)">lame_get_PeakSample</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the peak sample 

      float CDECL lame_get_PeakSample(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_quality(lame.std.lame_global_flags)">lame_get_quality</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      internal algorithm selection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_quant_comp_short(lame.std.lame_global_flags)">lame_get_quant_comp_short</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select a different "best quantization" function. default=0  

       int CDECL lame_get_quant_comp_short(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_quant_comp(lame.std.lame_global_flags)">lame_get_quant_comp</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select a different "best quantization" function. default=0  

       int CDECL lame_get_quant_comp(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_RadioGain(lame.std.lame_global_flags)">lame_get_RadioGain</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RadioGain value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_ReplayGain_decode(lame.std.lame_global_flags)">lame_get_ReplayGain_decode</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as 
       lame_set_decode_on_the_fly() && lame_set_findReplayGain()
       default = 0 (disabled) 

 int CDECL lame_get_ReplayGain_decode(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_ReplayGain_input(lame.std.lame_global_flags)">lame_get_ReplayGain_input</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as lame_set_findReplayGain() 
       default = 0 (disabled) 

 int CDECL lame_get_ReplayGain_input(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_scale_left(lame.std.lame_global_flags)">lame_get_scale_left</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the channel 0 (left) input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_scale_right(lame.std.lame_global_flags)">lame_get_scale_right</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the channel 1 (right) input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_scale(lame.std.lame_global_flags)">lame_get_scale</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_size_mp3buffer(lame.std.lame_global_flags)">lame_get_size_mp3buffer</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size (bytes) of mp3 data buffered, but not yet encoded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_strict_ISO(lame.std.lame_global_flags)">lame_get_strict_ISO</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enforce strict ISO compliance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_totalframes(lame.std.lame_global_flags)">lame_get_totalframes</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lame's estimate of the total number of frames to be encoded
       only valid if calling program set num_samples

 int CDECL lame_get_totalframes(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_useTemporal(lame.std.lame_global_flags)">lame_get_useTemporal</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use temporal masking effect (default = 1) 

 int CDECL lame_get_useTemporal(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_VBR_hard_min(lame.std.lame_global_flags)">lame_get_VBR_hard_min</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=strictly enforce VBR_min_bitrate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_VBR_max_bitrate_kbps(lame.std.lame_global_flags)">lame_get_VBR_max_bitrate_kbps</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_get_VBR_max_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_VBR_mean_bitrate_kbps(lame.std.lame_global_flags)">lame_get_VBR_mean_bitrate_kbps</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ignored except for VBR=vbr_abr (ABR mode)     

        int CDECL lame_get_VBR_mean_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_VBR_min_bitrate_kbps(lame.std.lame_global_flags)">lame_get_VBR_min_bitrate_kbps</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_get_VBR_min_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_VBR_q(lame.std.lame_global_flags)">lame_get_VBR_q</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBR quality level.  0=highest  9=lowest
     
        int CDECL lame_get_VBR_q(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_VBR(lame.std.lame_global_flags)">lame_get_VBR</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Types of VBR.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_get_version(lame.std.lame_global_flags)">lame_get_version</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version  0=MPEG-2  1=MPEG-1  (2=MPEG-2.5)    

 int CDECL lame_get_version(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_init_bitstream(lame.std.lame_global_flags)">lame_init_bitstream</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_init_old(lame.std.lame_global_flags)">lame_init_old</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obsolete version

 int CDECL lame_init_old(lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_init_params(lame.std.lame_global_flags)">lame_init_params</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REQUIRED:
 sets more internal configuration based on data provided above.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_init()">lame_init</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REQUIRED:
 initialize the encoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_mp3_tags_fid(lame.std.lame_global_flags, lame.std.FileUtil.FILE)">lame_mp3_tags_fid</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                  <A HREF="../../lame/std/FileUtil.FILE.html" title="class in lame.std">FileUtil.FILE</A>&nbsp;fid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 OPTIONAL:
 lame_mp3_tags_fid will append a Xing VBR tag to the mp3 file with file
 pointer fid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_print_config(lame.std.lame_global_flags)">lame_print_config</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_print_internals(lame.std.lame_global_flags)">lame_print_internals</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void CDECL lame_print_internals( const lame_global_flags *gfp);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_allow_diff_short(lame.std.lame_global_flags, int)">lame_set_allow_diff_short</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                          int&nbsp;allow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow blocktypes to differ between channels?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_analysis(lame.std.lame_global_flags, int)">lame_set_analysis</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                  int&nbsp;analysis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=cause Lame to collect data for an MP3 frame analyzer. default=0 
 int CDECL lame_set_analysis(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_asm_optimizations(lame.std.lame_global_flags, int, int)">lame_set_asm_optimizations</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                           int&nbsp;param1,
                           int&nbsp;param2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_asm_optimizations( lame_global_flags*  gfp, int, int );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_athaa_loudapprox(lame.std.lame_global_flags, int)">lame_set_athaa_loudapprox</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                          int&nbsp;loud)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select the loudness approximation used by the ATH adaptive auto-leveling  

 int CDECL lame_set_athaa_loudapprox( lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_athaa_sensitivity(lame.std.lame_global_flags, float)">lame_set_athaa_sensitivity</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                           float&nbsp;sen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adjust (in dB) the point below which adaptive ATH level adjustment occurs 

 int CDECL lame_set_athaa_sensitivity( lame_global_flags *, float);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_athaa_type(lame.std.lame_global_flags, int)">lame_set_athaa_type</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                    int&nbsp;ATHadjust)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select ATH adaptive adjustment type 

 int CDECL lame_set_athaa_type( lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_ATHlower(lame.std.lame_global_flags, float)">lame_set_ATHlower</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                  float&nbsp;ATHLower)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lower ATH by this many db 

 int CDECL lame_set_ATHlower(lame_global_flags *, float);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_ATHonly(lame.std.lame_global_flags, int)">lame_set_ATHonly</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                 int&nbsp;athOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only use ATH for masking 

 int CDECL lame_set_ATHonly(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_ATHshort(lame.std.lame_global_flags, int)">lame_set_ATHshort</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                  int&nbsp;athShort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only use ATH for short blocks 

 int CDECL lame_set_ATHshort(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_ATHtype(lame.std.lame_global_flags, int)">lame_set_ATHtype</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                 int&nbsp;ATHType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select ATH formula 

 int CDECL lame_set_ATHtype(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_brate(lame.std.lame_global_flags, int)">lame_set_brate</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
               int&nbsp;brate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set one of brate compression ratio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_bWriteVbrTag(lame.std.lame_global_flags, int)">lame_set_bWriteVbrTag</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                      int&nbsp;vbrTag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 = write a Xing VBR header frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_compression_ratio(lame.std.lame_global_flags, float)">lame_set_compression_ratio</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                           float&nbsp;ratio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_copyright(lame.std.lame_global_flags, int)">lame_set_copyright</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                   int&nbsp;cprght)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark as copyright.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_cwlimit(lame.std.lame_global_flags, int)">lame_set_cwlimit</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                 int&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predictability limit (ISO tonality formula) 

       int CDECL lame_set_cwlimit(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_debugf(lame.std.lame_global_flags, lame.std.LameMsgCallback)">lame_set_debugf</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                <A HREF="../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPTIONAL:
 Set printf like error/debug/message reporting functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_decode_on_the_fly(lame.std.lame_global_flags, int)">lame_set_decode_on_the_fly</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                           int&nbsp;onthefly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decode on the fly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_decode_only(lame.std.lame_global_flags, int)">lame_set_decode_only</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                     int&nbsp;deconly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=decode only.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_disable_reservoir(lame.std.lame_global_flags, int)">lame_set_disable_reservoir</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                           int&nbsp;preset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable the bit reservoir.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_emphasis(lame.std.lame_global_flags, int)">lame_set_emphasis</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                  int&nbsp;emph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Input PCM is emphased PCM (for instance from one of the rarely
       emphased CDs), it is STRONGLY not recommended to use this, because
       psycho does not take it into account, and last but not least many decoders
       ignore these bits      

 int CDECL lame_set_emphasis(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_error_protection(lame.std.lame_global_flags, int)">lame_set_error_protection</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                          int&nbsp;prot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_protection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_errorf(lame.std.lame_global_flags, lame.std.LameMsgCallback)">lame_set_errorf</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                <A HREF="../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 OPTIONAL:
 Set printf like error/debug/message reporting functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_exp_nspsytune(lame.std.lame_global_flags, int)">lame_set_exp_nspsytune</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                       int&nbsp;tune)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_exp_nspsytune2_int(lame.std.lame_global_flags, int, int)">lame_set_exp_nspsytune2_int</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                            int&nbsp;p1,
                            int&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int lame_set_exp_nspsytune2_int( lame_global_flags*, int, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_exp_nspsytune2_pointer(lame.std.lame_global_flags, int, int)">lame_set_exp_nspsytune2_pointer</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                int&nbsp;p1,
                                int&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * lame_set_exp_nspsytune2_pointer( lame_global_flags*, int, void *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_exp_nspsytune2_real(lame.std.lame_global_flags, int, float)">lame_set_exp_nspsytune2_real</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                             int&nbsp;p1,
                             float&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float lame_set_exp_nspsytune2_real( lame_global_flags*, int, float);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_experimentalX(lame.std.lame_global_flags, int)">lame_set_experimentalX</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                       int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_experimentalX(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_experimentalY(lame.std.lame_global_flags, int)">lame_set_experimentalY</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                       int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another experimental option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_experimentalZ(lame.std.lame_global_flags, int)">lame_set_experimentalZ</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                       int&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another experimental option.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_extension(lame.std.lame_global_flags, int)">lame_set_extension</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                   int&nbsp;ext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MP3 'private extension' bit  Meaningless.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_findPeakSample(lame.std.lame_global_flags, int)">lame_set_findPeakSample</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                        int&nbsp;findPeak)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as lame_set_decode_on_the_fly() 
       default = 0 (disabled) 

 int CDECL lame_set_findPeakSample(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_findReplayGain(lame.std.lame_global_flags, int)">lame_set_findReplayGain</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                        int&nbsp;repGain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perform ReplayGain analysis?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_force_ms(lame.std.lame_global_flags, int)">lame_set_force_ms</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                  int&nbsp;force)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;force_ms.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_force_short_blocks(lame.std.lame_global_flags, int)">lame_set_force_short_blocks</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flgas,
                            int&nbsp;force)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;force short blocks 

 int CDECL lame_set_force_short_blocks(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_free_format(lame.std.lame_global_flags, int)">lame_set_free_format</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                     int&nbsp;free)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use free_format?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_highpassfreq(lame.std.lame_global_flags, int)">lame_set_highpassfreq</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                      int&nbsp;freq)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq in Hz to apply highpass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_highpasswidth(lame.std.lame_global_flags, int)">lame_set_highpasswidth</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                       int&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of transition band, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_in_samplerate(lame.std.lame_global_flags, int)">lame_set_in_samplerate</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                       int&nbsp;rate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input sample rate in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_interChRatio(lame.std.lame_global_flags, float)">lame_set_interChRatio</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                      float&nbsp;interChRatio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use temporal masking effect (default = 1) 

 int CDECL lame_set_interChRatio(lame_global_flags *, float);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_lowpassfreq(lame.std.lame_global_flags, int)">lame_set_lowpassfreq</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                     int&nbsp;freq)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq in Hz to apply lowpass.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_lowpasswidth(lame.std.lame_global_flags, int)">lame_set_lowpasswidth</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                      int&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width of transition band, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_mode_automs(lame.std.lame_global_flags, int)">lame_set_mode_automs</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                     int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode_automs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_mode(lame.std.lame_global_flags, int)">lame_set_mode</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
              int&nbsp;MPEG_mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
      default: lame picks based on compression ration and input channels

 int CDECL lame_set_mode(lame_global_flags *, MPEG_mode);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_msfix(lame.std.lame_global_flags, double)">lame_set_msfix</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
               double&nbsp;msfix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void CDECL lame_set_msfix(lame_global_flags *, double);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_msgf(lame.std.lame_global_flags, lame.std.LameMsgCallback)">lame_set_msgf</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
              <A HREF="../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 OPTIONAL:
 Set printf like error/debug/message reporting functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_no_short_blocks(lame.std.lame_global_flags, int)">lame_set_no_short_blocks</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                         int&nbsp;noShort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable short blocks 

       int CDECL lame_set_no_short_blocks(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_noATH(lame.std.lame_global_flags, int)">lame_set_noATH</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
               int&nbsp;noATH)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disable ATH 

 int CDECL lame_set_noATH(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_nogap_currentindex(lame.std.lame_global_flags, int)">lame_set_nogap_currentindex</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                            int&nbsp;currindex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter for gapless encoding 

 int CDECL lame_set_nogap_currentindex(lame_global_flags* , int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_nogap_total(lame.std.lame_global_flags, int)">lame_set_nogap_total</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                     int&nbsp;total)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter for gapless encoding 

 int CDECL lame_set_nogap_total(lame_global_flags*, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_num_channels(lame.std.lame_global_flags, int)">lame_set_num_channels</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                      int&nbsp;channels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of channels in input stream. default=2  

 int CDECL lame_set_num_channels(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_num_samples(lame.std.lame_global_flags, int)">lame_set_num_samples</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                     int&nbsp;samples)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_ogg(lame.std.lame_global_flags, int)">lame_set_ogg</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
             int&nbsp;ogg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=encode a Vorbis .ogg file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_original(lame.std.lame_global_flags, int)">lame_set_original</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                  int&nbsp;original)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mark as original.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_out_samplerate(lame.std.lame_global_flags, int)">lame_set_out_samplerate</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                        int&nbsp;rate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      output sample rate in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_padding_type(lame.std.lame_global_flags, int)">lame_set_padding_type</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                      int&nbsp;padding_type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default)

       int CDECL lame_set_padding_type(lame_global_flags *, Padding_type);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_preset_expopts(lame.std.lame_global_flags, int)">lame_set_preset_expopts</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                        int&nbsp;expopts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for preset 

 int CDECL lame_set_preset_expopts(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_preset(lame.std.lame_global_flags, int)">lame_set_preset</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                int&nbsp;preset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_preset( lame_global_flags*  gfp, int );</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_quality(lame.std.lame_global_flags, int)">lame_set_quality</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                 int&nbsp;quality)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      internal algorithm selection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_quant_comp_short(lame.std.lame_global_flags, int)">lame_set_quant_comp_short</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                          int&nbsp;quant)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select a different "best quantization" function. default=0  

       int CDECL lame_set_quant_comp_short(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_quant_comp(lame.std.lame_global_flags, int)">lame_set_quant_comp</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                    int&nbsp;quant)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select a different "best quantization" function. default=0  

       int CDECL lame_set_quant_comp(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_ReplayGain_decode(lame.std.lame_global_flags, int)">lame_set_ReplayGain_decode</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                           int&nbsp;repGain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as 
       lame_set_decode_on_the_fly() && lame_set_findReplayGain()
       default = 0 (disabled) 

 int CDECL lame_set_ReplayGain_decode(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_ReplayGain_input(lame.std.lame_global_flags, int)">lame_set_ReplayGain_input</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                          int&nbsp;repGain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEPRECATED: now does the same as lame_set_findReplayGain() 
       default = 0 (disabled) 

 int CDECL lame_set_ReplayGain_input(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_scale_left(lame.std.lame_global_flags, float)">lame_set_scale_left</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                    float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the channel 0 (left) input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_scale_right(lame.std.lame_global_flags, float)">lame_set_scale_right</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                     float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the channel 1 (right) input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_scale(lame.std.lame_global_flags, float)">lame_set_scale</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
               float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale the input by this amount before encoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_strict_ISO(lame.std.lame_global_flags, int)">lame_set_strict_ISO</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                    int&nbsp;iso)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enforce strict ISO compliance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_useTemporal(lame.std.lame_global_flags, int)">lame_set_useTemporal</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                     int&nbsp;maskEffect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use temporal masking effect (default = 1) 

 int CDECL lame_set_useTemporal(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_VBR_hard_min(lame.std.lame_global_flags, int)">lame_set_VBR_hard_min</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                      int&nbsp;vbr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1=strictly enforce VBR_min_bitrate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_VBR_max_bitrate_kbps(lame.std.lame_global_flags, int)">lame_set_VBR_max_bitrate_kbps</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                              int&nbsp;bitrate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_VBR_max_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_VBR_mean_bitrate_kbps(lame.std.lame_global_flags, int)">lame_set_VBR_mean_bitrate_kbps</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                               int&nbsp;bitrate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ignored except for VBR=vbr_abr (ABR mode) 

        int CDECL lame_set_VBR_mean_bitrate_kbps(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_VBR_min_bitrate_kbps(lame.std.lame_global_flags, int)">lame_set_VBR_min_bitrate_kbps</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                              int&nbsp;bitrate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int CDECL lame_set_VBR_min_bitrate_kbps(const lame_global_flags *);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_VBR_q(lame.std.lame_global_flags, int)">lame_set_VBR_q</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
               int&nbsp;level)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBR quality level.  0=highest  9=lowest  

        int CDECL lame_set_VBR_q(lame_global_flags *, int);</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_set_VBR(lame.std.lame_global_flags, int)">lame_set_VBR</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
             int&nbsp;vbr_mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Types of VBR.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../lame/std/Lame.html#lame_stereo_mode_hist(lame.std.lame_global_flags, int[])">lame_stereo_mode_hist</A></B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                      int[]&nbsp;stereo_mode_count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 
 void CDECL lame_stereo_mode_hist( 
            const lame_global_flags *const gfp, 
            int stereo_mode_count[4] );  
 </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Lame()"><!-- --></A><H3>
Lame</H3>
<PRE>
public <B>Lame</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="lame_init()"><!-- --></A><H3>
lame_init</H3>
<PRE>
public static <A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A> <B>lame_init</B>()</PRE>
<DL>
<DD>REQUIRED:
 initialize the encoder.  sets default for all encoder parameters,
 returns NULL if some malloc()'s failed
 otherwise returns pointer to structure needed for all future
 API calls.

 <pre>lame_global_flags * CDECL lame_init(void);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_init_old(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_init_old</H3>
<PRE>
public static int <B>lame_init_old</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>obsolete version

 <pre>int CDECL lame_init_old(lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_num_samples(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_num_samples</H3>
<PRE>
public static int <B>lame_set_num_samples</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                       int&nbsp;samples)</PRE>
<DL>
<DD>number of samples.  default = 2^32-1   

 <pre>int CDECL lame_set_num_samples(lame_global_flags *, unsigned long);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_num_samples(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_num_samples</H3>
<PRE>
public static int <B>lame_get_num_samples</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>number of samples.  default = 2^32-1      

 <pre>unsigned long CDECL lame_get_num_samples(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_in_samplerate(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_in_samplerate</H3>
<PRE>
public static int <B>lame_set_in_samplerate</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                         int&nbsp;rate)</PRE>
<DL>
<DD>input sample rate in Hz.  default = 44100hz 

       <pre>int CDECL lame_set_in_samplerate(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_in_samplerate(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_in_samplerate</H3>
<PRE>
public static int <B>lame_get_in_samplerate</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>input sample rate in Hz.  default = 44100hz      

        <pre>int CDECL lame_get_in_samplerate(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_num_channels(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_num_channels</H3>
<PRE>
public static int <B>lame_set_num_channels</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                        int&nbsp;channels)</PRE>
<DL>
<DD>number of channels in input stream. default=2  

 <pre>int CDECL lame_set_num_channels(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_num_channels(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_num_channels</H3>
<PRE>
public static int <B>lame_get_num_channels</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>number of channels in input stream. default=2  

 <pre>int CDECL lame_get_num_channels(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_scale(lame.std.lame_global_flags, float)"><!-- --></A><H3>
lame_set_scale</H3>
<PRE>
public static int <B>lame_set_scale</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                 float&nbsp;scale)</PRE>
<DL>
<DD>scale the input by this amount before encoding.  default=0 (disabled)
 (not used by decoding routines)

 <pre>int CDECL lame_set_scale(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_scale(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_scale</H3>
<PRE>
public static float <B>lame_get_scale</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>scale the input by this amount before encoding.  default=0 (disabled)
 (not used by decoding routines)     

 <pre>float CDECL lame_get_scale(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_scale_left(lame.std.lame_global_flags, float)"><!-- --></A><H3>
lame_set_scale_left</H3>
<PRE>
public static int <B>lame_set_scale_left</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                      float&nbsp;scale)</PRE>
<DL>
<DD>scale the channel 0 (left) input by this amount before encoding.
        default=0 (disabled)
      (not used by decoding routines)

 <pre>int CDECL lame_set_scale_left(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_scale_left(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_scale_left</H3>
<PRE>
public static float <B>lame_get_scale_left</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>scale the channel 0 (left) input by this amount before encoding.
        default=0 (disabled)
      (not used by decoding routines)
     
 <pre>float CDECL lame_get_scale_left(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_scale_right(lame.std.lame_global_flags, float)"><!-- --></A><H3>
lame_set_scale_right</H3>
<PRE>
public static int <B>lame_set_scale_right</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                       float&nbsp;scale)</PRE>
<DL>
<DD>scale the channel 1 (right) input by this amount before encoding.
        default=0 (disabled)
      (not used by decoding routines)

 <pre>int CDECL lame_set_scale_right(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_scale_right(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_scale_right</H3>
<PRE>
public static float <B>lame_get_scale_right</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>scale the channel 1 (right) input by this amount before encoding.
        default=0 (disabled)
      (not used by decoding routines)     

 <pre>float CDECL lame_get_scale_right(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_out_samplerate(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_out_samplerate</H3>
<PRE>
public static int <B>lame_set_out_samplerate</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                          int&nbsp;rate)</PRE>
<DL>
<DD><pre>
      output sample rate in Hz.  default = 0, which means Lame picks best value
      based on the amount of compression.  MPEG only allows:
      MPEG1    32, 44.1,   48khz
      MPEG2    16, 22.05,  24
      MPEG2.5   8, 11.025, 12
      (not used by decoding routines)
 </pre>
 
 <pre>int CDECL lame_set_out_samplerate(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_out_samplerate(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_out_samplerate</H3>
<PRE>
public static int <B>lame_get_out_samplerate</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><pre>
      output sample rate in Hz.  default = 0, which means Lame picks best value
      based on the amount of compression.  MPEG only allows:
      MPEG1    32, 44.1,   48khz
      MPEG2    16, 22.05,  24
      MPEG2.5   8, 11.025, 12
      (not used by decoding routines)     
 </pre>
 <pre>int CDECL lame_get_out_samplerate(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_analysis(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_analysis</H3>
<PRE>
public static int <B>lame_set_analysis</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                    int&nbsp;analysis)</PRE>
<DL>
<DD>1=cause Lame to collect data for an MP3 frame analyzer. default=0 
 <pre>int CDECL lame_set_analysis(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_analysis(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_analysis</H3>
<PRE>
public static int <B>lame_get_analysis</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>1=cause Lame to collect data for an MP3 frame analyzer. default=0
    
 <pre>int CDECL lame_get_analysis(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_bWriteVbrTag(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_bWriteVbrTag</H3>
<PRE>
public static int <B>lame_set_bWriteVbrTag</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                        int&nbsp;vbrTag)</PRE>
<DL>
<DD>1 = write a Xing VBR header frame.
      default = 1
      this variable must have been added by a Hungarian notation Windows programmer :-)

 <pre>int CDECL lame_set_bWriteVbrTag(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_bWriteVbrTag(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_bWriteVbrTag</H3>
<PRE>
public static int <B>lame_get_bWriteVbrTag</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>1 = write a Xing VBR header frame.
      default = 1
      this variable must have been added by a Hungarian notation Windows programmer :-)


 <pre>int CDECL lame_get_bWriteVbrTag(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_decode_only(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_decode_only</H3>
<PRE>
public static int <B>lame_set_decode_only</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                       int&nbsp;deconly)</PRE>
<DL>
<DD>1=decode only.  use lame/mpglib to convert mp3/ogg to wav.  default=0 

 <pre>int CDECL lame_set_decode_only(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_decode_only(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_decode_only</H3>
<PRE>
public static int <B>lame_get_decode_only</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>1=decode only.  use lame/mpglib to convert mp3/ogg to wav.  default=0 

 <pre>int CDECL lame_get_decode_only(lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_ogg(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_ogg</H3>
<PRE>
public static int <B>lame_set_ogg</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                               int&nbsp;ogg)</PRE>
<DL>
<DD>1=encode a Vorbis .ogg file.  default=0 
 DEPRECATED

 <pre>int CDECL lame_set_ogg(lame_global_flags*, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_ogg(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_ogg</H3>
<PRE>
public static int <B>lame_get_ogg</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>1=encode a Vorbis .ogg file.  default=0 
 DEPRECATED

 <pre>int CDECL lame_get_ogg(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_quality(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_quality</H3>
<PRE>
public static int <B>lame_set_quality</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                   int&nbsp;quality)</PRE>
<DL>
<DD><pre>
      internal algorithm selection.  True quality is determined by the bitrate
      but this variable will effect quality by selecting expensive or cheap algorithms.
      quality=0..9.  0=best (very slow).  9=worst.
      recommended:  2     near-best quality, not too slow
                    5     good quality, fast
                    7     ok quality, really fast
 </pre>
 <pre>int CDECL lame_set_quality(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_quality(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_quality</H3>
<PRE>
public static int <B>lame_get_quality</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><pre>
      internal algorithm selection.  True quality is determined by the bitrate
      but this variable will effect quality by selecting expensive or cheap algorithms.
      quality=0..9.  0=best (very slow).  9=worst.
      recommended:  2     near-best quality, not too slow
                    5     good quality, fast
                    7     ok quality, really fast     
 </pre>
 <pre>int CDECL lame_get_quality(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_mode(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_mode</H3>
<PRE>
public static int <B>lame_set_mode</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                int&nbsp;MPEG_mode)</PRE>
<DL>
<DD>mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
      default: lame picks based on compression ration and input channels

 <pre>int CDECL lame_set_mode(lame_global_flags *, MPEG_mode);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_mode(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_mode</H3>
<PRE>
public static int <B>lame_get_mode</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
      default: lame picks based on compression ration and input channels     

 <pre>MPEG_mode CDECL lame_get_mode(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_mode_automs(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_mode_automs</H3>
<PRE>
public static int <B>lame_set_mode_automs</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                       int&nbsp;mode)</PRE>
<DL>
<DD>mode_automs.  Use a M/S mode with a switching threshold based on
      compression ratio
      DEPRECATED

 <pre>int CDECL lame_set_mode_automs(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_mode_automs(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_mode_automs</H3>
<PRE>
public static int <B>lame_get_mode_automs</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>mode_automs.  Use a M/S mode with a switching threshold based on
      compression ratio
      DEPRECATED

 <pre>int CDECL lame_get_mode_automs(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_force_ms(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_force_ms</H3>
<PRE>
public static int <B>lame_set_force_ms</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                    int&nbsp;force)</PRE>
<DL>
<DD>force_ms.  Force M/S for all frames.  For testing only.
      default = 0 (disabled)

 <pre>int CDECL lame_set_force_ms(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_force_ms(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_force_ms</H3>
<PRE>
public static int <B>lame_get_force_ms</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>force_ms.  Force M/S for all frames.  For testing only.
      default = 0 (disabled)

 <pre>int CDECL lame_get_force_ms(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_free_format(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_free_format</H3>
<PRE>
public static int <B>lame_set_free_format</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                       int&nbsp;free)</PRE>
<DL>
<DD>use free_format?  default = 0 (disabled) 

       <pre>int CDECL lame_set_free_format(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_free_format(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_free_format</H3>
<PRE>
public static int <B>lame_get_free_format</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>use free_format?  default = 0 (disabled) 

       <pre>int CDECL lame_get_free_format(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_findReplayGain(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_findReplayGain</H3>
<PRE>
public static int <B>lame_set_findReplayGain</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                          int&nbsp;repGain)</PRE>
<DL>
<DD>perform ReplayGain analysis?  default = 0 (disabled) 

 <pre>int CDECL lame_set_findReplayGain(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_findReplayGain(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_findReplayGain</H3>
<PRE>
public static int <B>lame_get_findReplayGain</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>perform ReplayGain analysis?  default = 0 (disabled) 

 <pre>int CDECL lame_get_findReplayGain(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_decode_on_the_fly(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_decode_on_the_fly</H3>
<PRE>
public static int <B>lame_set_decode_on_the_fly</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                             int&nbsp;onthefly)</PRE>
<DL>
<DD>decode on the fly. Search for the peak sample. If the ReplayGain
 analysis is enabled then perform the analysis on the decoded data
 stream. default = 0 (disabled) 
 NOTE: if this option is set the build-in decoder should not be used 

 <pre>int CDECL lame_set_decode_on_the_fly(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_decode_on_the_fly(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_decode_on_the_fly</H3>
<PRE>
public static int <B>lame_get_decode_on_the_fly</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>decode on the fly. Search for the peak sample. If the ReplayGain
 analysis is enabled then perform the analysis on the decoded data
 stream. default = 0 (disabled) 
 NOTE: if this option is set the build-in decoder should not be used 

 <pre>int CDECL lame_get_decode_on_the_fly(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_ReplayGain_input(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_ReplayGain_input</H3>
<PRE>
public static int <B>lame_set_ReplayGain_input</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                            int&nbsp;repGain)</PRE>
<DL>
<DD>DEPRECATED: now does the same as lame_set_findReplayGain() 
       default = 0 (disabled) 

 <pre>int CDECL lame_set_ReplayGain_input(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_ReplayGain_input(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_ReplayGain_input</H3>
<PRE>
public static int <B>lame_get_ReplayGain_input</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>DEPRECATED: now does the same as lame_set_findReplayGain() 
       default = 0 (disabled) 

 <pre>int CDECL lame_get_ReplayGain_input(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_ReplayGain_decode(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_ReplayGain_decode</H3>
<PRE>
public static int <B>lame_set_ReplayGain_decode</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                             int&nbsp;repGain)</PRE>
<DL>
<DD>DEPRECATED: now does the same as 
       lame_set_decode_on_the_fly() && lame_set_findReplayGain()
       default = 0 (disabled) 

 <pre>int CDECL lame_set_ReplayGain_decode(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_ReplayGain_decode(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_ReplayGain_decode</H3>
<PRE>
public static int <B>lame_get_ReplayGain_decode</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>DEPRECATED: now does the same as 
       lame_set_decode_on_the_fly() && lame_set_findReplayGain()
       default = 0 (disabled) 

 <pre>int CDECL lame_get_ReplayGain_decode(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_findPeakSample(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_findPeakSample</H3>
<PRE>
public static int <B>lame_set_findPeakSample</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                          int&nbsp;findPeak)</PRE>
<DL>
<DD>DEPRECATED: now does the same as lame_set_decode_on_the_fly() 
       default = 0 (disabled) 

 <pre>int CDECL lame_set_findPeakSample(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_findPeakSample(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_findPeakSample</H3>
<PRE>
public static int <B>lame_get_findPeakSample</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>DEPRECATED: now does the same as lame_set_decode_on_the_fly() 
       default = 0 (disabled) 

 <pre>int CDECL lame_get_findPeakSample(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_nogap_total(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_nogap_total</H3>
<PRE>
public static int <B>lame_set_nogap_total</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                       int&nbsp;total)</PRE>
<DL>
<DD>counter for gapless encoding 

 <pre>int CDECL lame_set_nogap_total(lame_global_flags*, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_nogap_total(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_nogap_total</H3>
<PRE>
public static int <B>lame_get_nogap_total</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>counter for gapless encoding 

 <pre>int CDECL lame_get_nogap_total(const lame_global_flags*);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_nogap_currentindex(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_nogap_currentindex</H3>
<PRE>
public static int <B>lame_set_nogap_currentindex</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                              int&nbsp;currindex)</PRE>
<DL>
<DD>counter for gapless encoding 

 <pre>int CDECL lame_set_nogap_currentindex(lame_global_flags* , int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_nogap_currentindex(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_nogap_currentindex</H3>
<PRE>
public static int <B>lame_get_nogap_currentindex</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>counter for gapless encoding 

 <pre>int CDECL lame_get_nogap_currentindex(const lame_global_flags*);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_errorf(lame.std.lame_global_flags, lame.std.LameMsgCallback)"><!-- --></A><H3>
lame_set_errorf</H3>
<PRE>
public static int <B>lame_set_errorf</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                  <A HREF="../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</PRE>
<DL>
<DD><pre>
 OPTIONAL:
 Set printf like error/debug/message reporting functions.
 The second argument has to be a pointer to a function which looks like
   void my_debugf(const char *format, va_list ap)
   {
       (void) vfprintf(stdout, format, ap);
   }
 If you use NULL as the value of the pointer in the set function, the
 lame buildin function will be used (prints to stderr).
 To quiet any output you have to replace the body of the example function
 with just "return;" and use it in the set function.
 </pre>
 <pre>int CDECL lame_set_errorf(lame_global_flags *,
                              void (*func)(const char *, va_list));</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_debugf(lame.std.lame_global_flags, lame.std.LameMsgCallback)"><!-- --></A><H3>
lame_set_debugf</H3>
<PRE>
public static int <B>lame_set_debugf</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                  <A HREF="../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</PRE>
<DL>
<DD>OPTIONAL:
 Set printf like error/debug/message reporting functions.
 The second argument has to be a pointer to a function which looks like
   void my_debugf(const char *format, va_list ap)
   {
       (void) vfprintf(stdout, format, ap);
   }
 If you use NULL as the value of the pointer in the set function, the
 lame buildin function will be used (prints to stderr).
 To quiet any output you have to replace the body of the example function
 with just "return;" and use it in the set function.

 <pre>int CDECL lame_set_debugf(lame_global_flags *,
                              void (*func)(const char *, va_list));</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_msgf(lame.std.lame_global_flags, lame.std.LameMsgCallback)"><!-- --></A><H3>
lame_set_msgf</H3>
<PRE>
public static int <B>lame_set_msgf</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                <A HREF="../../lame/std/LameMsgCallback.html" title="class in lame.std">LameMsgCallback</A>&nbsp;func)</PRE>
<DL>
<DD><pre>
 OPTIONAL:
 Set printf like error/debug/message reporting functions.
 The second argument has to be a pointer to a function which looks like
   void my_debugf(const char *format, va_list ap)
   {
       (void) vfprintf(stdout, format, ap);
   }
 If you use NULL as the value of the pointer in the set function, the
 lame buildin function will be used (prints to stderr).
 To quiet any output you have to replace the body of the example function
 with just "return;" and use it in the set function.
 </pre>
 <pre>int CDECL lame_set_msgf(lame_global_flags *,
                              void (*func)(const char *, va_list));</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_brate(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_brate</H3>
<PRE>
public static int <B>lame_set_brate</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                 int&nbsp;brate)</PRE>
<DL>
<DD>set one of brate compression ratio.  default is compression ratio of 11.  

 <pre>int CDECL lame_set_brate(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_brate(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_brate</H3>
<PRE>
public static int <B>lame_get_brate</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>set one of brate compression ratio.  default is compression ratio of 11.  

 <pre>int CDECL lame_get_brate(const lame_global_flags *);
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_compression_ratio(lame.std.lame_global_flags, float)"><!-- --></A><H3>
lame_set_compression_ratio</H3>
<PRE>
public static int <B>lame_set_compression_ratio</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                             float&nbsp;ratio)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_compression_ratio(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_compression_ratio</H3>
<PRE>
public static float <B>lame_get_compression_ratio</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_preset(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_preset</H3>
<PRE>
public static int <B>lame_set_preset</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                  int&nbsp;preset)</PRE>
<DL>
<DD><pre>int CDECL lame_set_preset( lame_global_flags*  gfp, int );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_asm_optimizations(lame.std.lame_global_flags, int, int)"><!-- --></A><H3>
lame_set_asm_optimizations</H3>
<PRE>
public static int <B>lame_set_asm_optimizations</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                             int&nbsp;param1,
                                             int&nbsp;param2)</PRE>
<DL>
<DD><pre>int CDECL lame_set_asm_optimizations( lame_global_flags*  gfp, int, int );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_copyright(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_copyright</H3>
<PRE>
public static int <B>lame_set_copyright</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                     int&nbsp;cprght)</PRE>
<DL>
<DD>mark as copyright.  default=0 

       <pre>int CDECL lame_set_copyright(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_copyright(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_copyright</H3>
<PRE>
public static int <B>lame_get_copyright</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>mark as copyright.  default=0 

       <pre>int CDECL lame_get_copyright(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_original(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_original</H3>
<PRE>
public static int <B>lame_set_original</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                    int&nbsp;original)</PRE>
<DL>
<DD>mark as original.  default=1 

       <pre>int CDECL lame_set_original(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_original(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_original</H3>
<PRE>
public static int <B>lame_get_original</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>mark as original.  default=1      

       <pre>int CDECL lame_get_original(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_error_protection(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_error_protection</H3>
<PRE>
public static int <B>lame_set_error_protection</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                            int&nbsp;prot)</PRE>
<DL>
<DD>error_protection.  Use 2 bytes from each frame for CRC checksum. default=0

       <pre>int CDECL lame_set_error_protection(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_error_protection(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_error_protection</H3>
<PRE>
public static int <B>lame_get_error_protection</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>error_protection.  Use 2 bytes from each frame for CRC checksum. default=0     

       <pre>int CDECL lame_get_error_protection(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_padding_type(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_padding_type</H3>
<PRE>
public static int <B>lame_set_padding_type</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                        int&nbsp;padding_type)</PRE>
<DL>
<DD>padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default)

       <pre>int CDECL lame_set_padding_type(lame_global_flags *, Padding_type);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_padding_type(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_padding_type</H3>
<PRE>
public static int <B>lame_get_padding_type</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default)    

       <pre>Padding_type CDECL lame_get_padding_type(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_extension(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_extension</H3>
<PRE>
public static int <B>lame_set_extension</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                     int&nbsp;ext)</PRE>
<DL>
<DD>MP3 'private extension' bit  Meaningless.  default=0 

 <pre>int CDECL lame_set_extension(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_extension(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_extension</H3>
<PRE>
public static int <B>lame_get_extension</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>MP3 'private extension' bit  Meaningless.  default=0 

 <pre>int CDECL lame_get_extension(const lame_global_flags *); </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_strict_ISO(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_strict_ISO</H3>
<PRE>
public static int <B>lame_set_strict_ISO</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                      int&nbsp;iso)</PRE>
<DL>
<DD>enforce strict ISO compliance.  default=0 

 <pre>int CDECL lame_set_strict_ISO(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_strict_ISO(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_strict_ISO</H3>
<PRE>
public static int <B>lame_get_strict_ISO</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>enforce strict ISO compliance.  default=0 

 <pre>int CDECL lame_get_strict_ISO(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_disable_reservoir(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_disable_reservoir</H3>
<PRE>
public static int <B>lame_set_disable_reservoir</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                             int&nbsp;preset)</PRE>
<DL>
<DD>disable the bit reservoir. For testing only. default=0

       <pre>int CDECL lame_set_disable_reservoir(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_disable_reservoir(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_disable_reservoir</H3>
<PRE>
public static int <B>lame_get_disable_reservoir</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>disable the bit reservoir. For testing only. default=0     

       <pre>int CDECL lame_get_disable_reservoir(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_quant_comp(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_quant_comp</H3>
<PRE>
public static int <B>lame_set_quant_comp</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                      int&nbsp;quant)</PRE>
<DL>
<DD>select a different "best quantization" function. default=0  

       <pre>int CDECL lame_set_quant_comp(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_quant_comp(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_quant_comp</H3>
<PRE>
public static int <B>lame_get_quant_comp</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>select a different "best quantization" function. default=0  

       <pre>int CDECL lame_get_quant_comp(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_quant_comp_short(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_quant_comp_short</H3>
<PRE>
public static int <B>lame_set_quant_comp_short</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                            int&nbsp;quant)</PRE>
<DL>
<DD>select a different "best quantization" function. default=0  

       <pre>int CDECL lame_set_quant_comp_short(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_quant_comp_short(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_quant_comp_short</H3>
<PRE>
public static int <B>lame_get_quant_comp_short</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>select a different "best quantization" function. default=0  

       <pre>int CDECL lame_get_quant_comp_short(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_experimentalX(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_experimentalX</H3>
<PRE>
public static int <B>lame_set_experimentalX</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                         int&nbsp;x)</PRE>
<DL>
<DD><pre>int CDECL lame_set_experimentalX(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_experimentalX(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_experimentalX</H3>
<PRE>
public static int <B>lame_get_experimentalX</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><pre>int CDECL lame_get_experimentalX(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_experimentalY(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_experimentalY</H3>
<PRE>
public static int <B>lame_set_experimentalY</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                         int&nbsp;y)</PRE>
<DL>
<DD>another experimental option.  for testing only 

 <pre>int CDECL lame_set_experimentalY(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_experimentalY(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_experimentalY</H3>
<PRE>
public static int <B>lame_get_experimentalY</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>another experimental option.  for testing only 

 <pre>int CDECL lame_get_experimentalY(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_experimentalZ(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_experimentalZ</H3>
<PRE>
public static int <B>lame_set_experimentalZ</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                         int&nbsp;z)</PRE>
<DL>
<DD>another experimental option.  for testing only 

 <pre>int CDECL lame_set_experimentalZ(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_experimentalZ(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_experimentalZ</H3>
<PRE>
public static int <B>lame_get_experimentalZ</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>another experimental option.  for testing only 

 <pre>int CDECL lame_get_experimentalZ(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_exp_nspsytune(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_exp_nspsytune</H3>
<PRE>
public static int <B>lame_set_exp_nspsytune</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                         int&nbsp;tune)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_exp_nspsytune(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_exp_nspsytune</H3>
<PRE>
public static int <B>lame_get_exp_nspsytune</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_msfix(lame.std.lame_global_flags, double)"><!-- --></A><H3>
lame_set_msfix</H3>
<PRE>
public static void <B>lame_set_msfix</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                  double&nbsp;msfix)</PRE>
<DL>
<DD><pre>void CDECL lame_set_msfix(lame_global_flags *, double);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_msfix(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_msfix</H3>
<PRE>
public static float <B>lame_get_msfix</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><pre>float CDECL lame_get_msfix(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_exp_nspsytune2_int(lame.std.lame_global_flags, int, int)"><!-- --></A><H3>
lame_set_exp_nspsytune2_int</H3>
<PRE>
public static int <B>lame_set_exp_nspsytune2_int</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                              int&nbsp;p1,
                                              int&nbsp;p2)</PRE>
<DL>
<DD><pre>int lame_set_exp_nspsytune2_int( lame_global_flags*, int, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_exp_nspsytune2_real(lame.std.lame_global_flags, int, float)"><!-- --></A><H3>
lame_set_exp_nspsytune2_real</H3>
<PRE>
public static float <B>lame_set_exp_nspsytune2_real</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                                 int&nbsp;p1,
                                                 float&nbsp;p2)</PRE>
<DL>
<DD><pre>float lame_set_exp_nspsytune2_real( lame_global_flags*, int, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_exp_nspsytune2_pointer(lame.std.lame_global_flags, int, int)"><!-- --></A><H3>
lame_set_exp_nspsytune2_pointer</H3>
<PRE>
public static int <B>lame_set_exp_nspsytune2_pointer</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                                  int&nbsp;p1,
                                                  int&nbsp;p2)</PRE>
<DL>
<DD><pre>void * lame_set_exp_nspsytune2_pointer( lame_global_flags*, int, void *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_VBR(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_VBR</H3>
<PRE>
public static int <B>lame_set_VBR</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                               int&nbsp;vbr_mode)</PRE>
<DL>
<DD>Types of VBR.  default = vbr_off = CBR 

 <pre>int CDECL lame_set_VBR(lame_global_flags *, vbr_mode);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_VBR(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_VBR</H3>
<PRE>
public static int <B>lame_get_VBR</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>Types of VBR.  default = vbr_off = CBR 
     
 <pre>vbr_mode CDECL lame_get_VBR(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_VBR_q(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_VBR_q</H3>
<PRE>
public static int <B>lame_set_VBR_q</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                 int&nbsp;level)</PRE>
<DL>
<DD>VBR quality level.  0=highest  9=lowest  

        <pre>int CDECL lame_set_VBR_q(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_VBR_q(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_VBR_q</H3>
<PRE>
public static int <B>lame_get_VBR_q</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>VBR quality level.  0=highest  9=lowest
     
        <pre>int CDECL lame_get_VBR_q(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_VBR_mean_bitrate_kbps(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_VBR_mean_bitrate_kbps</H3>
<PRE>
public static int <B>lame_set_VBR_mean_bitrate_kbps</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                                 int&nbsp;bitrate)</PRE>
<DL>
<DD>Ignored except for VBR=vbr_abr (ABR mode) 

        <pre>int CDECL lame_set_VBR_mean_bitrate_kbps(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_VBR_mean_bitrate_kbps(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_VBR_mean_bitrate_kbps</H3>
<PRE>
public static int <B>lame_get_VBR_mean_bitrate_kbps</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>Ignored except for VBR=vbr_abr (ABR mode)     

        <pre>int CDECL lame_get_VBR_mean_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_VBR_min_bitrate_kbps(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_VBR_min_bitrate_kbps</H3>
<PRE>
public static int <B>lame_set_VBR_min_bitrate_kbps</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                                int&nbsp;bitrate)</PRE>
<DL>
<DD><pre>int CDECL lame_set_VBR_min_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_VBR_min_bitrate_kbps(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_VBR_min_bitrate_kbps</H3>
<PRE>
public static int <B>lame_get_VBR_min_bitrate_kbps</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><pre>int CDECL lame_get_VBR_min_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_VBR_max_bitrate_kbps(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_VBR_max_bitrate_kbps</H3>
<PRE>
public static int <B>lame_set_VBR_max_bitrate_kbps</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                                int&nbsp;bitrate)</PRE>
<DL>
<DD><pre>int CDECL lame_set_VBR_max_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_VBR_max_bitrate_kbps(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_VBR_max_bitrate_kbps</H3>
<PRE>
public static int <B>lame_get_VBR_max_bitrate_kbps</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><pre>int CDECL lame_get_VBR_max_bitrate_kbps(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_VBR_hard_min(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_VBR_hard_min</H3>
<PRE>
public static int <B>lame_set_VBR_hard_min</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                        int&nbsp;vbr)</PRE>
<DL>
<DD>1=strictly enforce VBR_min_bitrate.  Normally it will be violated for
      analog silence

 <pre>int CDECL lame_set_VBR_hard_min(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_VBR_hard_min(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_VBR_hard_min</H3>
<PRE>
public static int <B>lame_get_VBR_hard_min</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>1=strictly enforce VBR_min_bitrate.  Normally it will be violated for
      analog silence

 <pre>int CDECL lame_get_VBR_hard_min(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_preset_expopts(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_preset_expopts</H3>
<PRE>
public static int <B>lame_set_preset_expopts</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                          int&nbsp;expopts)</PRE>
<DL>
<DD>for preset 

 <pre>int CDECL lame_set_preset_expopts(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_lowpassfreq(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_lowpassfreq</H3>
<PRE>
public static int <B>lame_set_lowpassfreq</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                       int&nbsp;freq)</PRE>
<DL>
<DD>freq in Hz to apply lowpass. Default = 0 = lame chooses.  -1 = disabled 

 <pre>int CDECL lame_set_lowpassfreq(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_lowpassfreq(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_lowpassfreq</H3>
<PRE>
public static int <B>lame_get_lowpassfreq</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>freq in Hz to apply lowpass. Default = 0 = lame chooses.  -1 = disabled 

 <pre>int CDECL lame_get_lowpassfreq(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_lowpasswidth(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_lowpasswidth</H3>
<PRE>
public static int <B>lame_set_lowpasswidth</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                        int&nbsp;width)</PRE>
<DL>
<DD>width of transition band, in Hz.  Default = one polyphase filter band 

 <pre>int CDECL lame_set_lowpasswidth(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_lowpasswidth(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_lowpasswidth</H3>
<PRE>
public static int <B>lame_get_lowpasswidth</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>width of transition band, in Hz.  Default = one polyphase filter band 

 <pre>int CDECL lame_get_lowpasswidth(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_highpassfreq(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_highpassfreq</H3>
<PRE>
public static int <B>lame_set_highpassfreq</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                        int&nbsp;freq)</PRE>
<DL>
<DD>freq in Hz to apply highpass. Default = 0 = lame chooses.  -1 = disabled 

 <pre>int CDECL lame_set_highpassfreq(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_highpassfreq(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_highpassfreq</H3>
<PRE>
public static int <B>lame_get_highpassfreq</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>freq in Hz to apply highpass. Default = 0 = lame chooses.  -1 = disabled 

 <pre>int CDECL lame_get_highpassfreq(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_highpasswidth(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_highpasswidth</H3>
<PRE>
public static int <B>lame_set_highpasswidth</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                         int&nbsp;width)</PRE>
<DL>
<DD>width of transition band, in Hz.  Default = one polyphase filter band 

 <pre>int CDECL lame_set_highpasswidth(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_highpasswidth(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_highpasswidth</H3>
<PRE>
public static int <B>lame_get_highpasswidth</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>width of transition band, in Hz.  Default = one polyphase filter band 

 <pre>int CDECL lame_get_highpasswidth(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_ATHonly(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_ATHonly</H3>
<PRE>
public static int <B>lame_set_ATHonly</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                   int&nbsp;athOnly)</PRE>
<DL>
<DD>only use ATH for masking 

 <pre>int CDECL lame_set_ATHonly(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_ATHonly(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_ATHonly</H3>
<PRE>
public static int <B>lame_get_ATHonly</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>only use ATH for masking 

 <pre>int CDECL lame_get_ATHonly(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_ATHshort(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_ATHshort</H3>
<PRE>
public static int <B>lame_set_ATHshort</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                    int&nbsp;athShort)</PRE>
<DL>
<DD>only use ATH for short blocks 

 <pre>int CDECL lame_set_ATHshort(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_ATHshort(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_ATHshort</H3>
<PRE>
public static int <B>lame_get_ATHshort</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>only use ATH for short blocks 

 <pre>int CDECL lame_get_ATHshort(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_noATH(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_noATH</H3>
<PRE>
public static int <B>lame_set_noATH</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                 int&nbsp;noATH)</PRE>
<DL>
<DD>disable ATH 

 <pre>int CDECL lame_set_noATH(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_noATH(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_noATH</H3>
<PRE>
public static int <B>lame_get_noATH</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>disable ATH 

 <pre>int CDECL lame_get_noATH(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_ATHtype(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_ATHtype</H3>
<PRE>
public static int <B>lame_set_ATHtype</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                   int&nbsp;ATHType)</PRE>
<DL>
<DD>select ATH formula 

 <pre>int CDECL lame_set_ATHtype(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_ATHtype(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_ATHtype</H3>
<PRE>
public static int <B>lame_get_ATHtype</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>select ATH formula 

 <pre>int CDECL lame_get_ATHtype(lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_ATHlower(lame.std.lame_global_flags, float)"><!-- --></A><H3>
lame_set_ATHlower</H3>
<PRE>
public static int <B>lame_set_ATHlower</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                    float&nbsp;ATHLower)</PRE>
<DL>
<DD>lower ATH by this many db 

 <pre>int CDECL lame_set_ATHlower(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_ATHlower(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_ATHlower</H3>
<PRE>
public static float <B>lame_get_ATHlower</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>lower ATH by this many db 

 <pre>floag CDECL lame_get_ATHlower(lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_athaa_type(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_athaa_type</H3>
<PRE>
public static int <B>lame_set_athaa_type</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                      int&nbsp;ATHadjust)</PRE>
<DL>
<DD>select ATH adaptive adjustment type 

 <pre>int CDECL lame_set_athaa_type( lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_athaa_type(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_athaa_type</H3>
<PRE>
public static int <B>lame_get_athaa_type</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>select ATH adaptive adjustment type 

 <pre>int CDECL lame_get_athaa_type( const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_athaa_loudapprox(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_athaa_loudapprox</H3>
<PRE>
public static int <B>lame_set_athaa_loudapprox</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                            int&nbsp;loud)</PRE>
<DL>
<DD>select the loudness approximation used by the ATH adaptive auto-leveling  

 <pre>int CDECL lame_set_athaa_loudapprox( lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_athaa_loudapprox(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_athaa_loudapprox</H3>
<PRE>
public static int <B>lame_get_athaa_loudapprox</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>select the loudness approximation used by the ATH adaptive auto-leveling  

 <pre>int CDECL lame_get_athaa_loudapprox( const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_athaa_sensitivity(lame.std.lame_global_flags, float)"><!-- --></A><H3>
lame_set_athaa_sensitivity</H3>
<PRE>
public static int <B>lame_set_athaa_sensitivity</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                             float&nbsp;sen)</PRE>
<DL>
<DD>adjust (in dB) the point below which adaptive ATH level adjustment occurs 

 <pre>int CDECL lame_set_athaa_sensitivity( lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_athaa_sensitivity(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_athaa_sensitivity</H3>
<PRE>
public static float <B>lame_get_athaa_sensitivity</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>adjust (in dB) the point below which adaptive ATH level adjustment occurs 

 <pre>float CDECL lame_get_athaa_sensitivity( const lame_global_flags* );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_cwlimit(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_cwlimit</H3>
<PRE>
public static int <B>lame_set_cwlimit</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                   int&nbsp;limit)</PRE>
<DL>
<DD>predictability limit (ISO tonality formula) 

       <pre>int CDECL lame_set_cwlimit(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_cwlimit(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_cwlimit</H3>
<PRE>
public static int <B>lame_get_cwlimit</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>predictability limit (ISO tonality formula) 

       <pre>int CDECL lame_get_cwlimit(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_allow_diff_short(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_allow_diff_short</H3>
<PRE>
public static int <B>lame_set_allow_diff_short</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                            int&nbsp;allow)</PRE>
<DL>
<DD>allow blocktypes to differ between channels?
      default: 0 for jstereo, 1 for stereo

 <pre>int CDECL lame_set_allow_diff_short(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_allow_diff_short(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_allow_diff_short</H3>
<PRE>
public static int <B>lame_get_allow_diff_short</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>allow blocktypes to differ between channels?
      default: 0 for jstereo, 1 for stereo

 <pre>int CDECL lame_get_allow_diff_short(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_useTemporal(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_useTemporal</H3>
<PRE>
public static int <B>lame_set_useTemporal</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                       int&nbsp;maskEffect)</PRE>
<DL>
<DD>use temporal masking effect (default = 1) 

 <pre>int CDECL lame_set_useTemporal(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_useTemporal(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_useTemporal</H3>
<PRE>
public static int <B>lame_get_useTemporal</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>use temporal masking effect (default = 1) 

 <pre>int CDECL lame_get_useTemporal(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_interChRatio(lame.std.lame_global_flags, float)"><!-- --></A><H3>
lame_set_interChRatio</H3>
<PRE>
public static int <B>lame_set_interChRatio</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                        float&nbsp;interChRatio)</PRE>
<DL>
<DD>use temporal masking effect (default = 1) 

 <pre>int CDECL lame_set_interChRatio(lame_global_flags *, float);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_interChRatio(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_interChRatio</H3>
<PRE>
public static float <B>lame_get_interChRatio</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>use temporal masking effect (default = 1) 

 <pre>float CDECL lame_get_interChRatio(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_no_short_blocks(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_no_short_blocks</H3>
<PRE>
public static int <B>lame_set_no_short_blocks</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                           int&nbsp;noShort)</PRE>
<DL>
<DD>disable short blocks 

       <pre>int CDECL lame_set_no_short_blocks(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_no_short_blocks(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_no_short_blocks</H3>
<PRE>
public static int <B>lame_get_no_short_blocks</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>disable short blocks 

       <pre>int CDECL lame_get_no_short_blocks(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_force_short_blocks(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_force_short_blocks</H3>
<PRE>
public static int <B>lame_set_force_short_blocks</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flgas,
                                              int&nbsp;force)</PRE>
<DL>
<DD>force short blocks 

 <pre>int CDECL lame_set_force_short_blocks(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_force_short_blocks(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_force_short_blocks</H3>
<PRE>
public static int <B>lame_get_force_short_blocks</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>force short blocks 

 <pre>int CDECL lame_get_force_short_blocks(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_set_emphasis(lame.std.lame_global_flags, int)"><!-- --></A><H3>
lame_set_emphasis</H3>
<PRE>
public static int <B>lame_set_emphasis</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                    int&nbsp;emph)</PRE>
<DL>
<DD>Input PCM is emphased PCM (for instance from one of the rarely
       emphased CDs), it is STRONGLY not recommended to use this, because
       psycho does not take it into account, and last but not least many decoders
       ignore these bits      

 <pre>int CDECL lame_set_emphasis(lame_global_flags *, int);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_emphasis(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_emphasis</H3>
<PRE>
public static int <B>lame_get_emphasis</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>Input PCM is emphased PCM (for instance from one of the rarely
       emphased CDs), it is STRONGLY not recommended to use this, because
       psycho does not take it into account, and last but not least many decoders
       ignore these bits      

 <pre>int CDECL lame_get_emphasis(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_version(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_version</H3>
<PRE>
public static int <B>lame_get_version</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>version  0=MPEG-2  1=MPEG-1  (2=MPEG-2.5)    

 <pre>int CDECL lame_get_version(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_encoder_delay(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_encoder_delay</H3>
<PRE>
public static int <B>lame_get_encoder_delay</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>encoder delay   

 <pre>int CDECL lame_get_encoder_delay(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_encoder_padding(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_encoder_padding</H3>
<PRE>
public static int <B>lame_get_encoder_padding</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>padding appended to the input to make sure decoder can fully decode
      all input.  Note that this value can only be calculated during the
      call to lame_encoder_flush().  Before lame_encoder_flush() has
      been called, the value of encoder_padding = 0.

 <pre>int CDECL lame_get_encoder_padding(const lame_global_flags *);  </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_framesize(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_framesize</H3>
<PRE>
public static int <B>lame_get_framesize</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>size of MPEG frame 

      <pre>int CDECL lame_get_framesize(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_mf_samples_to_encode(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_mf_samples_to_encode</H3>
<PRE>
public static int <B>lame_get_mf_samples_to_encode</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>number of PCM samples buffered, but not yet encoded to mp3 data. 

 <pre>int CDECL lame_get_mf_samples_to_encode( const lame_global_flags*  gfp );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_size_mp3buffer(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_size_mp3buffer</H3>
<PRE>
public static int <B>lame_get_size_mp3buffer</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>size (bytes) of mp3 data buffered, but not yet encoded.
      this is the number of bytes which would be output by a call to 
      lame_encode_flush_nogap.  NOTE: lame_encode_flush() will return
      more bytes than this because it will encode the reamining buffered
      PCM samples before flushing the mp3 buffers.

 <pre>int CDECL lame_get_size_mp3buffer( const lame_global_flags*  gfp );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_frameNum(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_frameNum</H3>
<PRE>
public static int <B>lame_get_frameNum</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>number of frames encoded so far 

      <pre>int CDECL lame_get_frameNum(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_totalframes(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_totalframes</H3>
<PRE>
public static int <B>lame_get_totalframes</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>lame's estimate of the total number of frames to be encoded
       only valid if calling program set num_samples

 <pre>int CDECL lame_get_totalframes(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_RadioGain(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_RadioGain</H3>
<PRE>
public static int <B>lame_get_RadioGain</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>RadioGain value. Multiplied by 10 and rounded to the nearest. 

 <pre>int CDECL lame_get_RadioGain(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_AudiophileGain(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_AudiophileGain</H3>
<PRE>
public static int <B>lame_get_AudiophileGain</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>AudiophileGain value. Multipled by 10 and rounded to the nearest. 

      <pre>int CDECL lame_get_AudiophileGain(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_PeakSample(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_PeakSample</H3>
<PRE>
public static float <B>lame_get_PeakSample</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>the peak sample 

      <pre>float CDECL lame_get_PeakSample(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_noclipGainChange(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_noclipGainChange</H3>
<PRE>
public static int <B>lame_get_noclipGainChange</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>Gain change required for preventing clipping. The value is correct only if 
       peak sample searching was enabled. If negative then the waveform 
       already does not clip. The value is multiplied by 10 and rounded up. 

      <pre>int CDECL lame_get_noclipGainChange(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_get_noclipScale(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_get_noclipScale</H3>
<PRE>
public static float <B>lame_get_noclipScale</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>user-specified scale factor required for preventing clipping. Value is 
       correct only if peak sample searching was enabled and no user-specified
       scaling was performed. If negative then either the waveform already does
       not clip or the value cannot be determined 

 <pre>float CDECL lame_get_noclipScale(const lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_init_params(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_init_params</H3>
<PRE>
public static int <B>lame_init_params</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>REQUIRED:
 sets more internal configuration based on data provided above.
 returns -1 if something failed.

 <pre>int CDECL lame_init_params(lame_global_flags * const );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="get_lame_version()"><!-- --></A><H3>
get_lame_version</H3>
<PRE>
public static java.lang.String <B>get_lame_version</B>()</PRE>
<DL>
<DD>OPTIONAL:
 get the version number, in a string. of the form:  
 "3.63 (beta)" or just "3.63". 

 <pre>const char*  CDECL get_lame_version( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="get_lame_short_version()"><!-- --></A><H3>
get_lame_short_version</H3>
<PRE>
public static java.lang.String <B>get_lame_short_version</B>()</PRE>
<DL>
<DD><pre>const char*  CDECL get_lame_short_version( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="get_lame_very_short_version()"><!-- --></A><H3>
get_lame_very_short_version</H3>
<PRE>
public static java.lang.String <B>get_lame_very_short_version</B>()</PRE>
<DL>
<DD><pre>const char*  CDECL get_lame_very_short_version( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="get_psy_version()"><!-- --></A><H3>
get_psy_version</H3>
<PRE>
public static java.lang.String <B>get_psy_version</B>()</PRE>
<DL>
<DD><pre>const char*  CDECL get_psy_version( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="get_lame_url()"><!-- --></A><H3>
get_lame_url</H3>
<PRE>
public static java.lang.String <B>get_lame_url</B>()</PRE>
<DL>
<DD><pre>const char*  CDECL get_lame_url( void );</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="get_lame_version_numerical(lame.std.lame_version_t)"><!-- --></A><H3>
get_lame_version_numerical</H3>
<PRE>
public static void <B>get_lame_version_numerical</B>(<A HREF="../../lame/std/lame_version_t.html" title="class in lame.std">lame_version_t</A>&nbsp;version)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_print_config(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_print_config</H3>
<PRE>
public static void <B>lame_print_config</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_print_internals(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_print_internals</H3>
<PRE>
public static void <B>lame_print_internals</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD><pre>void CDECL lame_print_internals( const lame_global_flags *gfp);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_buffer(lame.std.lame_global_flags, short[], short[], int, byte[], int)"><!-- --></A><H3>
lame_encode_buffer</H3>
<PRE>
public static int <B>lame_encode_buffer</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                     short[]&nbsp;buffer_l,
                                     short[]&nbsp;buffer_r,
                                     int&nbsp;nsamples,
                                     byte[]&nbsp;mp3buf,
                                     int&nbsp;mp3buf_size)</PRE>
<DL>
<DD><pre>
 input pcm data, output (maybe) mp3 frames.
 This routine handles all buffering, resampling and filtering for you.
 
 return code     number of bytes output in mp3buf. Can be 0 
                 -1:  mp3buf was too small
                 -2:  malloc() problem
                 -3:  lame_init_params() not called
                 -4:  psycho acoustic problems 
 
 The required mp3buf_size can be computed from num_samples, 
 samplerate and encoding rate, but here is a worst case estimate:
 
 mp3buf_size in bytes = 1.25*num_samples + 7200
 
 I think a tighter bound could be:  (mt, March 2000)
 MPEG1:
    num_samples*(bitrate/8)/samplerate + 4*1152*(bitrate/8)/samplerate + 512
 MPEG2:
    num_samples*(bitrate/8)/samplerate + 4*576*(bitrate/8)/samplerate + 256
 
 but test first if you use that!
 
 set mp3buf_size = 0 and Lame will not check if mp3buf_size is
 large enough.
 
 NOTE:
 if gfp->num_channels=2, but gfp->mode = 3 (mono), the L & R channels
 will be averaged into the L channel before encoding only the L channel
 This will overwrite the data in buffer_l[] and buffer_r[].
 </pre>
 <pre>
    int CDECL lame_encode_buffer (
            lame_global_flags*  gfp,            global context handle  
            const short int     buffer_l [],    PCM data for left channel     
            const short int     buffer_r [],    PCM data for right channel    
            const int           nsamples,       number of samples per channel 
            unsigned char*      mp3buf,         pointer to encoded MP3 stream 
            const int           mp3buf_size );  number of valid octets in this
                                                  stream
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_buffer(lame.std.lame_global_flags, byte[], byte[], int, byte[], int)"><!-- --></A><H3>
lame_encode_buffer</H3>
<PRE>
public static int <B>lame_encode_buffer</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                     byte[]&nbsp;buffer_l,
                                     byte[]&nbsp;buffer_r,
                                     int&nbsp;nsamples,
                                     byte[]&nbsp;mp3buf,
                                     int&nbsp;mp3buf_size)</PRE>
<DL>
<DD>This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../lame/std/Lame.html#lame_encode_buffer(lame.std.lame_global_flags, short[], short[], int, byte[], int)"><CODE>lame_encode_buffer(lame_global_flags,short[],short[],int,byte[],int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_buffer_interleaved(lame.std.lame_global_flags, short[], int, byte[], int)"><!-- --></A><H3>
lame_encode_buffer_interleaved</H3>
<PRE>
public static int <B>lame_encode_buffer_interleaved</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                                 short[]&nbsp;pcm,
                                                 int&nbsp;num_samples,
                                                 byte[]&nbsp;mp3buf,
                                                 int&nbsp;mp3buf_size)</PRE>
<DL>
<DD>as above (lame_encode_buffer), but input has L & R channel data interleaved.
 NOTE: 
 num_samples = number of samples in the L (or R)
 channel, not the total number of samples in pcm[]  

 <pre>
 int CDECL lame_encode_buffer_interleaved(
        lame_global_flags*  gfp,            global context handlei 
        short int           pcm[],          PCM data for left and right
                                              channel, interleaved   
        int                 num_samples,    number of samples per channel,
                                              _not_ number of samples in
                                              pcm[]                  
        unsigned char*      mp3buf,         pointer to encoded MP3 stream 
        int                 mp3buf_size );  number of valid octets in this
                                              stream                 
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_buffer_interleaved(lame.std.lame_global_flags, byte[], int, byte[], int)"><!-- --></A><H3>
lame_encode_buffer_interleaved</H3>
<PRE>
public static int <B>lame_encode_buffer_interleaved</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                                 byte[]&nbsp;pcm,
                                                 int&nbsp;num_samples,
                                                 byte[]&nbsp;mp3buf,
                                                 int&nbsp;mp3buf_size)</PRE>
<DL>
<DD>This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../lame/std/Lame.html#lame_encode_buffer_interleaved(lame.std.lame_global_flags, short[], int, byte[], int)"><CODE>lame_encode_buffer_interleaved(lame_global_flags,short[],int,byte[],int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_buffer_float(lame.std.lame_global_flags, float[], float[], int, byte[], int)"><!-- --></A><H3>
lame_encode_buffer_float</H3>
<PRE>
public static int <B>lame_encode_buffer_float</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                           float[]&nbsp;buffer_l,
                                           float[]&nbsp;buffer_r,
                                           int&nbsp;nsamples,
                                           byte[]&nbsp;mp3buf,
                                           int&nbsp;mp3buf_size)</PRE>
<DL>
<DD>as lame_encode_buffer, but for 'float's.
 !! NOTE: !! data must still be scaled to be in the same range as 
 short int, +/- 32768  

 <pre>
     int CDECL lame_encode_buffer_float(
            lame_global_flags*  gfp,           // global context handle  
            const float     buffer_l [],       // PCM data for left channel     
            const float     buffer_r [],       // PCM data for right channel    
            const int           nsamples,      // number of samples per channel 
            unsigned char*      mp3buf,        // pointer to encoded MP3 stream 
            const int           mp3buf_size ); // number of valid octets in this stream   
      </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_buffer_long(lame.std.lame_global_flags, int[], int[], int, byte[], int)"><!-- --></A><H3>
lame_encode_buffer_long</H3>
<PRE>
public static int <B>lame_encode_buffer_long</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                          int[]&nbsp;buffer_l,
                                          int[]&nbsp;buffer_r,
                                          int&nbsp;nsamples,
                                          byte[]&nbsp;mp3buf,
                                          int&nbsp;mp3buf_size)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_buffer_long2(lame.std.lame_global_flags, int[], int[], int, byte[], int)"><!-- --></A><H3>
lame_encode_buffer_long2</H3>
<PRE>
public static int <B>lame_encode_buffer_long2</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                           int[]&nbsp;buffer_l,
                                           int[]&nbsp;buffer_r,
                                           int&nbsp;nsamples,
                                           byte[]&nbsp;mp3buf,
                                           int&nbsp;mp3buf_size)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_buffer_int(lame.std.lame_global_flags, int[], int[], int, byte[], int)"><!-- --></A><H3>
lame_encode_buffer_int</H3>
<PRE>
public static int <B>lame_encode_buffer_int</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                         int[]&nbsp;buffer_l,
                                         int[]&nbsp;buffer_r,
                                         int&nbsp;nsamples,
                                         byte[]&nbsp;mp3buf,
                                         int&nbsp;mp3buf_size)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_flush(lame.std.lame_global_flags, byte[], int)"><!-- --></A><H3>
lame_encode_flush</H3>
<PRE>
public static int <B>lame_encode_flush</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                    byte[]&nbsp;mp3buf,
                                    int&nbsp;size)</PRE>
<DL>
<DD><pre>
 REQUIRED:
 lame_encode_flush will flush the intenal PCM buffers, padding with 
 0's to make sure the final frame is complete, and then flush
 the internal MP3 buffers, and thus may return a 
 final few mp3 frames.  'mp3buf' should be at least 7200 bytes long
 to hold all possible emitted data.

 will also write id3v1 tags (if any) into the bitstream

 return code = number of bytes output to mp3buf. Can be 0
 </pre>
 <pre>
 int CDECL lame_encode_flush(
         lame_global_flags *  gfp,     // global context handle         
         unsigned char*       mp3buf,  // pointer to encoded MP3 stream  
         int                  size);   // number of valid octets in this stream 
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_encode_flush_nogap(lame.std.lame_global_flags, byte[], int)"><!-- --></A><H3>
lame_encode_flush_nogap</H3>
<PRE>
public static int <B>lame_encode_flush_nogap</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                          byte[]&nbsp;mp3buf,
                                          int&nbsp;size)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_init_bitstream(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_init_bitstream</H3>
<PRE>
public static int <B>lame_init_bitstream</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_bitrate_hist(lame.std.lame_global_flags, int[])"><!-- --></A><H3>
lame_bitrate_hist</H3>
<PRE>
public static void <B>lame_bitrate_hist</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                     int[]&nbsp;bitrate_count)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_bitrate_kbps(lame.std.lame_global_flags, int[])"><!-- --></A><H3>
lame_bitrate_kbps</H3>
<PRE>
public static void <B>lame_bitrate_kbps</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                     int[]&nbsp;bitrate_kbps)</PRE>
<DL>
<DD>See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 <pre>
 void CDECL lame_bitrate_kbps( 
            const lame_global_flags *const gfp, 
            int bitrate_kbps [14] );  
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_stereo_mode_hist(lame.std.lame_global_flags, int[])"><!-- --></A><H3>
lame_stereo_mode_hist</H3>
<PRE>
public static void <B>lame_stereo_mode_hist</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                         int[]&nbsp;stereo_mode_count)</PRE>
<DL>
<DD>See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 <pre>
 void CDECL lame_stereo_mode_hist( 
            const lame_global_flags *const gfp, 
            int stereo_mode_count[4] );  
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_bitrate_stereo_mode_hist(lame.std.lame_global_flags, int[][])"><!-- --></A><H3>
lame_bitrate_stereo_mode_hist</H3>
<PRE>
public static void <B>lame_bitrate_stereo_mode_hist</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                                 int[][]&nbsp;bitrate_stmode_count)</PRE>
<DL>
<DD>See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 <pre>
 void CDECL lame_bitrate_stereo_mode_hist ( 
        const lame_global_flags * const gfp, 
        int  bitrate_stmode_count [14] [4] );
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_block_type_hist(lame.std.lame_global_flags, int[])"><!-- --></A><H3>
lame_block_type_hist</H3>
<PRE>
public static void <B>lame_block_type_hist</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                        int[]&nbsp;btype_count)</PRE>
<DL>
<DD>See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 <pre>
 void CDECL lame_block_type_hist (
        const lame_global_flags * const gfp, 
        int btype_count[6] );
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_bitrate_block_type_hist(lame.std.lame_global_flags, int[][])"><!-- --></A><H3>
lame_bitrate_block_type_hist</H3>
<PRE>
public static void <B>lame_bitrate_block_type_hist</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;gfp,
                                                int[][]&nbsp;bitrate_btype_count)</PRE>
<DL>
<DD>See <A HREF="../../lame/std/Lame.html#lame_bitrate_hist(lame.std.lame_global_flags, int[])"><CODE>lame_bitrate_hist(lame_global_flags,int[])</CODE></A>

 <pre>
 void CDECL lame_bitrate_block_type_hist ( 
        const lame_global_flags * const gfp, 
        int bitrate_btype_count[14][6] );
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_mp3_tags_fid(lame.std.lame_global_flags, lame.std.FileUtil.FILE)"><!-- --></A><H3>
lame_mp3_tags_fid</H3>
<PRE>
public static void <B>lame_mp3_tags_fid</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags,
                                     <A HREF="../../lame/std/FileUtil.FILE.html" title="class in lame.std">FileUtil.FILE</A>&nbsp;fid)</PRE>
<DL>
<DD><pre>
 OPTIONAL:
 lame_mp3_tags_fid will append a Xing VBR tag to the mp3 file with file
 pointer fid.  These calls perform forward and backwards seeks, so make
 sure fid is a real file.  Make sure lame_encode_flush has been called,
 and all mp3 data has been written to the file before calling this
 function.
 NOTE:
 if VBR  tags are turned off by the user, or turned off by Lame because
 the output is not a regular file, this call does nothing
 </pre>
 <pre>void CDECL lame_mp3_tags_fid(lame_global_flags *,FILE* fid);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_close(lame.std.lame_global_flags)"><!-- --></A><H3>
lame_close</H3>
<PRE>
public static int <B>lame_close</B>(<A HREF="../../lame/std/lame_global_flags.html" title="class in lame.std">lame_global_flags</A>&nbsp;flags)</PRE>
<DL>
<DD>REQUIRED:
 final call to free all remaining buffers

 <pre>int  CDECL lame_close (lame_global_flags *);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode_init()"><!-- --></A><H3>
lame_decode_init</H3>
<PRE>
public static int <B>lame_decode_init</B>()</PRE>
<DL>
<DD>required call to initialize decoder 
 NOTE: the decoder should not be used when encoding is performed
 with decoding on the fly 

 <pre>int CDECL lame_decode_init(void);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode(byte[], int, short[], short[])"><!-- --></A><H3>
lame_decode</H3>
<PRE>
public static int <B>lame_decode</B>(byte[]&nbsp;mp3buf,
                              int&nbsp;len,
                              short[]&nbsp;pcm_l,
                              short[]&nbsp;pcm_r)</PRE>
<DL>
<DD><pre>
 input 1 mp3 frame, output (maybe) pcm data.  

  nout = lame_decode(mp3buf,len,pcm_l,pcm_r);

 input:  
    len          :  number of bytes of mp3 data in mp3buf
    mp3buf[len]  :  mp3 data to be decoded

 output:
    nout:  -1    : decoding error
            0    : need more data before we can complete the decode 
           >0    : returned 'nout' samples worth of data in pcm_l,pcm_r
    pcm_l[nout]  : left channel data
    pcm_r[nout]  : right channel data 
 </pre>
 <pre>
    int CDECL lame_decode(
            unsigned char *  mp3buf,
            int              len,
            short            pcm_l[],
            short            pcm_r[] ); 
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode(byte[], int, byte[], byte[])"><!-- --></A><H3>
lame_decode</H3>
<PRE>
public static int <B>lame_decode</B>(byte[]&nbsp;mp3buf,
                              int&nbsp;len,
                              byte[]&nbsp;pcm_l,
                              byte[]&nbsp;pcm_r)</PRE>
<DL>
<DD>This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../lame/std/Lame.html#lame_decode(byte[], int, short[], short[])"><CODE>lame_decode(byte[],int,short[],short[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode_headers(byte[], int, short[], short[], lame.std.mp3data_struct)"><!-- --></A><H3>
lame_decode_headers</H3>
<PRE>
public static int <B>lame_decode_headers</B>(byte[]&nbsp;mp3buf,
                                      int&nbsp;len,
                                      short[]&nbsp;pcm_l,
                                      short[]&nbsp;pcm_r,
                                      <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data)</PRE>
<DL>
<DD>same as lame_decode, and also returns mp3 header data 

 <pre>
    int CDECL lame_decode_headers(
            unsigned char*   mp3buf,
            int              len,
            short            pcm_l[],
            short            pcm_r[],
            mp3data_struct*  mp3data );
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode_headers(byte[], int, byte[], byte[], lame.std.mp3data_struct)"><!-- --></A><H3>
lame_decode_headers</H3>
<PRE>
public static int <B>lame_decode_headers</B>(byte[]&nbsp;mp3buf,
                                      int&nbsp;len,
                                      byte[]&nbsp;pcm_l,
                                      byte[]&nbsp;pcm_r,
                                      <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data)</PRE>
<DL>
<DD>This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../lame/std/Lame.html#lame_decode_headers(byte[], int, short[], short[], lame.std.mp3data_struct)"><CODE>lame_decode_headers(byte[],int,short[],short[],mp3data_struct)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode1(byte[], int, short[], short[])"><!-- --></A><H3>
lame_decode1</H3>
<PRE>
public static int <B>lame_decode1</B>(byte[]&nbsp;mp3buf,
                               int&nbsp;len,
                               short[]&nbsp;pcm_l,
                               short[]&nbsp;pcm_r)</PRE>
<DL>
<DD>same as lame_decode, but returns at most one frame 

 <pre>
 int CDECL lame_decode1(
            unsigned char*  mp3buf,
            int             len,
            short           pcm_l[],
            short           pcm_r[] ); 
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode1(byte[], int, byte[], byte[])"><!-- --></A><H3>
lame_decode1</H3>
<PRE>
public static int <B>lame_decode1</B>(byte[]&nbsp;mp3buf,
                               int&nbsp;len,
                               byte[]&nbsp;pcm_l,
                               byte[]&nbsp;pcm_r)</PRE>
<DL>
<DD>This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../lame/std/Lame.html#lame_decode1(byte[], int, short[], short[])"><CODE>lame_decode1(byte[],int,short[],short[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode1_headers(byte[], int, short[], short[], lame.std.mp3data_struct)"><!-- --></A><H3>
lame_decode1_headers</H3>
<PRE>
public static int <B>lame_decode1_headers</B>(byte[]&nbsp;mp3buf,
                                       int&nbsp;len,
                                       short[]&nbsp;pcm_l,
                                       short[]&nbsp;pcm_r,
                                       <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data)</PRE>
<DL>
<DD>same as lame_decode1, but returns at most one frame and mp3 header data 

 <pre>
    int CDECL lame_decode1_headers(
            unsigned char*   mp3buf,
            int              len,
            short            pcm_l[],
            short            pcm_r[],
            mp3data_struct*  mp3data );
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode1_headers(byte[], int, byte[], byte[], lame.std.mp3data_struct)"><!-- --></A><H3>
lame_decode1_headers</H3>
<PRE>
public static int <B>lame_decode1_headers</B>(byte[]&nbsp;mp3buf,
                                       int&nbsp;len,
                                       byte[]&nbsp;pcm_l,
                                       byte[]&nbsp;pcm_r,
                                       <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data)</PRE>
<DL>
<DD>This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../lame/std/Lame.html#lame_decode1_headers(byte[], int, short[], short[], lame.std.mp3data_struct)"><CODE>lame_decode1_headers(byte[],int,short[],short[],mp3data_struct)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode1_headersB(byte[], int, short[], short[], lame.std.mp3data_struct, com.innowhere.jnieasy.core.data.NativeInteger, com.innowhere.jnieasy.core.data.NativeInteger)"><!-- --></A><H3>
lame_decode1_headersB</H3>
<PRE>
public static int <B>lame_decode1_headersB</B>(byte[]&nbsp;mp3buf,
                                        int&nbsp;len,
                                        short[]&nbsp;pcm_l,
                                        short[]&nbsp;pcm_r,
                                        <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data,
                                        com.innowhere.jnieasy.core.data.NativeInteger&nbsp;enc_delay,
                                        com.innowhere.jnieasy.core.data.NativeInteger&nbsp;enc_padding)</PRE>
<DL>
<DD>same as lame_decode1_headers, but also returns enc_delay and enc_padding
       from VBR Info tag, (-1 if no info tag was found) 

 <pre>
    int CDECL lame_decode1_headersB(
            unsigned char*   mp3buf,
            int              len,
            short            pcm_l[],
            short            pcm_r[],
            mp3data_struct*  mp3data,
            int              *enc_delay,
            int              *enc_padding ); 
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode1_headersB(byte[], int, byte[], byte[], lame.std.mp3data_struct, com.innowhere.jnieasy.core.data.NativeInteger, com.innowhere.jnieasy.core.data.NativeInteger)"><!-- --></A><H3>
lame_decode1_headersB</H3>
<PRE>
public static int <B>lame_decode1_headersB</B>(byte[]&nbsp;mp3buf,
                                        int&nbsp;len,
                                        byte[]&nbsp;pcm_l,
                                        byte[]&nbsp;pcm_r,
                                        <A HREF="../../lame/std/mp3data_struct.html" title="class in lame.std">mp3data_struct</A>&nbsp;mp3data,
                                        com.innowhere.jnieasy.core.data.NativeInteger&nbsp;enc_delay,
                                        com.innowhere.jnieasy.core.data.NativeInteger&nbsp;enc_padding)</PRE>
<DL>
<DD>This is a convenience method using byte[] array instead of short[], the byte[] buffer used
 must be 2x the length of the analogous short[] version.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../lame/std/Lame.html#lame_decode1_headersB(byte[], int, short[], short[], lame.std.mp3data_struct, com.innowhere.jnieasy.core.data.NativeInteger, com.innowhere.jnieasy.core.data.NativeInteger)"><CODE>lame_decode1_headersB(byte[],int,short[],short[],mp3data_struct,NativeInteger,NativeInteger)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lame_decode_exit()"><!-- --></A><H3>
lame_decode_exit</H3>
<PRE>
public static int <B>lame_decode_exit</B>()</PRE>
<DL>
<DD>cleanup call to exit decoder  

 <pre>int CDECL lame_decode_exit(void);</pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Lame.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../lame/std/FileUtil.FILE.html" title="class in lame.std"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../lame/std/lame_errorcodes_t.html" title="interface in lame.std"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?lame/std/Lame.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Lame.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

                
                Copyright  2006-2008 Jose Maria Arranz. All Rights Reserved.
                
            
</BODY>
</HTML>
